<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces - gym - 101550 - C.Card Hand Sorting(最长公共子序列)]]></title>
    <url>%2F2018%2F11%2F05%2FCodeforces%20-%20gym%20-%20101550%20-%20C.Card%20Hand%20Sorting(%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97)%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/gym/101550/attachments 题意： 输入一个 $n$ 表示有 $n$ 张牌 牌一共有 $4$ 种颜色 ${s, h, d, c}$ 牌上的符号有(从小到大) ${2,3,4,5,6,7,8,9,T, J, Q, K,A}$ 每张牌给的格式为：符号+牌的颜色 如：$2h$ , $Jd$ 问是否以一种排列满足 相同颜色的牌放在一起 相同颜色的牌要 递增 或 递减 的排列 颜色的顺序可以随便 使得这一种排列放回原来的排列步数最少的多少？ 数据范围： $1 &lt;= n &lt;= 52$ 样例：$input$ 1234567842h Th 8c Qh79d As 2s Qd 2c Jd 8h42h 3h 9c 8c $output$ 12345120 解题思路：那么可以先暴力求出所有的排列情况，然后求出每种排列与原排列的最长公共子序列，那么答案为 $min(n - 最长公共子序列)$ AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;int n;int f[300];char s[55][3];int a[55],b[55],p[6],pos[6];int dp[55][55];vector&lt;int&gt; G[6];void Init()&#123; for(int i = '1';i &lt;= '9';i++) f[i] = i - '0'; f['T'] = 10; f['J'] = 11; f['Q'] = 12; f['K'] = 13; f['A'] = 14; p[1] = 1; p[2] = 2; p[3] = 3; p[4] = 4;&#125;bool cmp(int x,int y)&#123; return x &gt; y;&#125;int Solve()&#123; int res = 0; memset(dp,0,sizeof(dp)); for(int i = 2;i &lt;= n + 1;i++)&#123; for(int j = 2;j &lt;= n + 1;j++)&#123; if(a[i - 1] == b[j - 1]) dp[i][j] = max(dp[i][j],dp[i - 1][j - 1] + 1); else dp[i][j] = max(dp[i][j - 1],dp[i - 1][j]); &#125; &#125; return n - dp[n + 1][n + 1];&#125;int main()&#123; scanf("%d",&amp;n); int ans = 1 &lt;&lt; 30; Init(); for(int i = 1;i &lt;= n;i++) scanf("%s",s[i] + 1); do&#123; G[1].clear(); G[2].clear(); G[3].clear(); G[4].clear(); for(int i = 1;i &lt;= 4;i++) pos[p[i]] = i; for(int i = 1;i &lt;= n;i++)&#123; if(s[i][2] == 's') a[i] = pos[1] * 100 + f[s[i][1]], G[1].push_back(a[i]); else if(s[i][2] == 'h')&#123; a[i] = pos[2] * 100 + f[s[i][1]], G[2].push_back(a[i]); &#125; else if(s[i][2] == 'd')&#123; a[i] = pos[3] * 100 + f[s[i][1]], G[3].push_back(a[i]); &#125; else if(s[i][2] == 'c')&#123; a[i] = pos[4] * 100 + f[s[i][1]], G[4].push_back(a[i]); &#125; &#125; for(int j = 0;j &lt;= 15;j++)&#123; int tot = 0; for(int i = 0;i &lt;= 3;i++)&#123; if((j &amp; (1 &lt;&lt; i)) == 0)&#123; // small -&gt; big sort(G[p[i + 1]].begin(),G[p[i + 1]].end()); &#125; else&#123; // big -&gt; small sort(G[p[i + 1]].begin(),G[p[i + 1]].end(),cmp); &#125; for(int k = 0;k &lt; G[p[i + 1]].size();k++)&#123; b[++tot] = G[p[i + 1]][k]; &#125; &#125; ans = min(ans,Solve()); &#125; &#125;while(next_permutation(p + 1,p + 1 + 4)); printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>最长公共子序列</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>最长公共子序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCA模板]]></title>
    <url>%2F2018%2F11%2F04%2FLCA%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;# define MAXN 500001using namespace std;int n, m, s;int f[MAXN][25], deep[MAXN];vector &lt;int&gt; vec[MAXN];inline void dfs(int u)&#123; int i, v; deep[u] = deep[f[u][0]] + 1; for(i = 0; f[u][i]; i++) f[u][i + 1] = f[f[u][i]][i]; for(i = 0; i &lt; vec[u].size(); i++) &#123; v = vec[u][i]; if(!deep[v]) f[v][0] = u, dfs(v); &#125;&#125;inline int lca(int x, int y)&#123; int i; if(deep[x] &lt; deep[y]) swap(x, y); for(i = 20; i &gt;= 0; i--) if(deep[f[x][i]] &gt;= deep[y]) x = f[x][i]; if(x == y) return x; for(i = 20; i &gt;= 0; i--) if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0];&#125;int main()&#123; int i, x, y; scanf("%d %d %d",&amp;n,&amp;m,&amp;s) for(i = 1; i &lt; n; i++) &#123; x = get_num(); y = get_num(); vec[x].push_back(y); vec[y].push_back(x); &#125; dfs(s); for(i = 1; i &lt;= m; i++) &#123; scanf("%d %d", &amp;x, &amp;y); printf("%d\n", lca(x, y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces - gym - 101550 - A.Artwork(并查集)]]></title>
    <url>%2F2018%2F11%2F04%2FCodeforces%20-%20gym%20-%20101550%20-%20A.Artwork(%E5%B9%B6%E6%9F%A5%E9%9B%86)%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/gym/101550/attachments 题意：有一个 $n*m$ 的矩阵，初始格子都为白色，然后有 $q$ 个操作，每个操作给你一条线段的两个端点，$(x_1,y_1)$ $(x_2,y_2)$ , 然后把这条线段上的格子涂黑，问当前（每个操作不独立）有白色格子联通块？ 数据范围： $1 &lt;= n ,m&lt;= 1000$ $1 &lt;= q &lt;= 1e4$ $1 &lt;= x_1 &lt;= x_2 &lt;= n$ $1 &lt;= y_1 &lt;= y_2 &lt;= m$ 4s 样例：$input$ 1234564 6 52 2 2 61 3 4 32 5 3 54 6 4 61 6 4 6 $output$ 1234513343 解题思路：利用并查集，倒着推，在删除黑格时，判断四个方向会不会多产生白色联通块或减少联通块。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1005;const int MaxN = 1e6 + 5;int a[maxn][maxn],ans[10005];int n,m,q,num,flag;int nx,ny,id,nid;bool vis[maxn][maxn];int father[MaxN];struct NODE&#123; int x_1,y_1; int x_2,y_2;&#125;node[10005];inline int GetID(int x,int y)&#123; return m * (x - 1) + y;&#125;int Find(int x)&#123; if(x == father[x]) return x; return father[x] = Find(father[x]);&#125;inline bool Check(int x,int y)&#123; if(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m) return true; return false;&#125;void Dfs(int x,int y,int F)&#123; vis[x][y] = 1; int now = GetID(x,y); if(Find(now) != F) father[Find(now)] = father[Find(F)]; for(int i = -1;i &lt;= 1;i++)&#123; for(int j = -1;j &lt;= 1;j++)&#123; int nx = x + i; int ny = y + j; if(i * j == 0 &amp;&amp; Check(nx,ny) &amp;&amp; !vis[nx][ny] &amp;&amp; a[nx][ny] == 0)&#123; Dfs(nx,ny,Find(now)); &#125; &#125; &#125;&#125;void Get()&#123; if(Check(nx,ny) &amp;&amp; a[nx][ny] == 0)&#123; nid = GetID(nx,ny); if(Find(nid) != Find(id))&#123; if(flag == 1) num--; father[Find(nid)] = father[Find(id)]; &#125; flag = 1; &#125;&#125;void Solve(int x,int y)&#123; flag = 0; id = GetID(x,y); nx = x + 1; // up ny = y; Get(); nx = x - 1; // down ny = y; Get(); nx = x; // left ny = y - 1; Get(); nx = x; // right ny = y + 1; Get(); if(flag == 0) num++;&#125;int main()&#123; num = 0; scanf("%d %d %d",&amp;n,&amp;m,&amp;q); for(int i = 1;i &lt;= q;i++)&#123; scanf("%d %d %d %d",&amp;node[i].x_1,&amp;node[i].y_1,&amp;node[i].x_2,&amp;node[i].y_2); if(node[i].x_1 == node[i].x_2)&#123; for(int j = node[i].y_1;j &lt;= node[i].y_2;j++) a[node[i].x_1][j]++; &#125; else&#123; for(int j = node[i].x_1;j &lt;= node[i].x_2;j++) a[j][node[i].y_1]++; &#125; &#125; for(int i = 1;i &lt;= n * m;i++) father[i] = i; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= m;j++)&#123; if(a[i][j] == 0 &amp;&amp; !vis[i][j])&#123; num++; Dfs(i,j,Find(GetID(i,j))); &#125; &#125; &#125; ans[q] = num; for(int i = q;i &gt;= 1;i--)&#123; if(node[i].x_1 == node[i].x_2)&#123; for(int j = node[i].y_1;j &lt;= node[i].y_2;j++)&#123; a[node[i].x_1][j]--; int nowx = node[i].x_1; int nowy = j; if(a[nowx][nowy] == 0)&#123; Solve(nowx,nowy); &#125; &#125; &#125; else&#123; for(int j = node[i].x_1;j &lt;= node[i].x_2;j++)&#123; a[j][node[i].y_1]--; int nowx = j; int nowy = node[i].y_1; if(a[nowx][nowy] == 0)&#123; Solve(nowx,nowy); &#125; &#125; &#125; ans[i - 1] = num; &#125; for(int i = 1;i &lt;= q;i++) printf("%d\n",ans[i]);&#125;]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读题单词]]></title>
    <url>%2F2018%2F11%2F04%2F%E8%AF%BB%E9%A2%98%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[$excluding$ : 不包括 $ cheat$ : 作弊 $against​$ ：反对]]></content>
      <categories>
        <category>读题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces - gym - 101873 - C.Joyride!(Dijkstra+状态转移)]]></title>
    <url>%2F2018%2F10%2F29%2FCodeforces%20-%20gym%20-%20101873%20-%20C.Joyride!(Dijkstra%2B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB)%2F</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/gym/101873/problem/C 题意： 给你一副无向图，有 $n$ 个点，第 $i$ 个点花费时间为 $t_i$ 和 花费价钱为 $p_i$ $m$ 条边，经过每条边的花费时间都为 $t$ 问：从 $1$ 点出发，最后回到 $1$ 点时花费时间恰好为 $x$ ，最少花费价钱为多少？（可以在同一个点不动，但还是要花费时间和价钱，只要经过就花），如果不能恰好到达 $1$ 点，就输出 $It$ $is$ $a$ $trap.$ 数据范围： $1 &lt;= x &lt;= 1000$ $1 &lt;= n,m &lt;= 1000$ $1 &lt;= t &lt;= 1000 $ 样例：$input$ 12345678910111213141516171819202144 4 11 22 33 44 11 22 15 43 364 4 11 22 33 44 11 22 15 43 3 $output$ 12385 解题思路：因为题目要求最小花费价钱，所以第一反应就要想到跑个最短路。那么现在的问题就是这么解决每个点的状态？ 因为 $x$ 不超过 $1000$ ，我们可以把每个点的状态设为：$dp[i][j]$ 当在第 $i$ 点，花费时间为 $j$ 时的最少花费价钱。 然后我们就可以按照 $Dijkstra$ 转移了。(但这个复杂度我不太清楚这么算……) AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int inf = 1 &lt;&lt; 30;const int maxn = 1e3;struct Node&#123; int id,x,cost; Node () &#123;&#125; Node (int _id,int _x,int _cost)&#123; id = _id; x = _x; cost = _cost; &#125; bool friend operator &lt; (Node a,Node b)&#123; return a.cost &gt; b.cost; &#125;&#125;;int dp[2 * maxn + 5][maxn + 5];vector&lt;int&gt; G[maxn];int t[2 * maxn + 5],p[2 * maxn + 5];int T,n,m,X;void Init(int s)&#123; for(int i = 0;i &lt;= 2 * n;i++)&#123; for(int j = 0;j &lt;= X;j++)&#123; dp[i][j] = inf; &#125; &#125; dp[s][t[s]] = p[s];&#125;void Dijstra(int s)&#123; Init(s); priority_queue&lt;Node&gt; pq; pq.push(Node(s,t[s],p[s])); while(!pq.empty())&#123; Node now = pq.top(); pq.pop(); for(int i = 0;i &lt; G[now.id].size();i++)&#123; int tmp; int v = G[now.id][i]; if(abs(v - now.id) == n) tmp = 0; else tmp = T; tmp = now.x + tmp + t[v]; //printf("tmp = %d ,v = %d\n",tmp,v); //printf("** %d\n",dp[v][tmp]); //printf("%d %d %d %d\n",now.id,now.x,p[v],dp[now.id][now.x] + p[v]); if(tmp &lt;= X &amp;&amp; dp[v][tmp] &gt; dp[now.id][now.x] + p[v])&#123; dp[v][tmp] = dp[now.id][now.x] + p[v]; pq.push(Node(v,tmp,dp[v][tmp])); &#125; &#125; &#125;&#125;bool vis[2 * maxn + 5][2 * maxn + 5];int main()&#123; scanf("%d",&amp;X); scanf("%d %d %d",&amp;n,&amp;m,&amp;T); for(int i = 1;i &lt;= m;i++)&#123; int u,v; scanf("%d %d",&amp;u,&amp;v); G[u].push_back(v); G[v].push_back(u); &#125; for(int i = 1;i &lt;= n;i++)&#123; scanf("%d %d",&amp;t[i],&amp;p[i]); t[i + n] = t[i]; p[i + n] = p[i]; &#125; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 0;j &lt; G[i].size();j++)&#123; int tmp = G[i][j]; if(vis[i + n][tmp] == 0)&#123; G[i + n].push_back(tmp); G[tmp].push_back(i + n); vis[i + n][tmp] = 1; vis[tmp][i + n] = 1; &#125; if(vis[i + n][tmp + n] == 0)&#123; G[i + n].push_back(tmp + n); G[tmp + n].push_back(i + n); vis[i + n][tmp + n] = 1; vis[tmp + n][i + n] = 1; &#125; &#125; G[i].push_back(i + n); G[i + n].push_back(i); &#125; Dijstra(1); int mi = inf; mi = min(mi,dp[1][X]); mi = min(mi,dp[1 + n][X]); if(mi == inf) printf("It is a trap.\n"); else printf("%d\n",mi);&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set的用法(C++)]]></title>
    <url>%2F2018%2F10%2F28%2Fset%E7%9A%84%E7%94%A8%E6%B3%95(C%2B%2B)%2F</url>
    <content type="text"><![CDATA[set 的函数调用12345678910111213141516171819202122232425262728293031323334353637c++ stl容器set成员函数:begin()--返回指向第一个元素的迭代器c++ stl容器set成员函数:clear()--清除所有元素c++ stl容器set成员函数:count()--返回某个值元素的个数c++ stl容器set成员函数:empty()--如果集合为空，返回truec++ stl容器set成员函数:end()--返回指向最后一个元素的迭代器c++ stl容器set成员函数:equal_range()--返回集合中与给定值相等的上下限的两个迭代器c++ stl容器set成员函数:erase()--删除集合中的元素c++ stl容器set成员函数:find()--返回一个指向被查找到元素的迭代器c++ stl容器set成员函数:get_allocator()--返回集合的分配器c++ stl容器set成员函数:insert()--在集合中插入元素c++ stl容器set成员函数:lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器c++ stl容器set成员函数:key_comp()--返回一个用于元素间值比较的函数c++ stl容器set成员函数:max_size()--返回集合能容纳的元素的最大限值c++ stl容器set成员函数:rbegin()--返回指向集合中最后一个元素的反向迭代器c++ stl容器set成员函数:rend()--返回指向集合中第一个元素的反向迭代器c++ stl容器set成员函数:size()--集合中元素的数目c++ stl容器set成员函数:swap()--交换两个集合变量c++ stl容器set成员函数:upper_bound()--返回大于某个值元素的迭代器c++ stl容器set成员函数:value_comp()--返回一个用于比较元素间的值的函数 c++ stl集合set插入,遍历用法举例1234567891011121314151617181920#include&lt;iostream&gt; #include&lt;set&gt; using namespace std; //set插入元素操作 int main() &#123; //定义一个int型集合对象s,当前没有任何元素.由www.169it.com搜集整理 set&lt;int&gt; s; s.insert(8); //第一次插入8，可以插入 s.insert(1); s.insert(12); s.insert(6); s.insert(8); //第二次插入8，重复元素，不会插入 set&lt;int&gt;::iterator it; //定义前向迭代器 //中序遍历集合中的所有元素 for(it=s.begin();it!=s.end();it++) cout&lt;&lt;*it&lt;&lt;endl; system("pause"); return 0; &#125;]]></content>
      <categories>
        <category>set</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces- 518 - div2 - D.Array Without Local Maximums(DP计数)]]></title>
    <url>%2F2018%2F10%2F28%2FCodeforces-%20518%20-%20div2%20-%20D.Array%20Without%20Local%20Maximums(DP)%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/1068/problem/D 题意： 输入一个 $n$ ：表示有一个长度为 $n$ 的 $a$ 序列。 $a_i$ 的范围为 $1 -&gt; 200$ 和 $-1$ 。 如果 $a_i = -1$ ，那么里的值可以改为任意数且满足以下三个条件 $1$. $a_1 ≤ a_2$ $2$. $a_n &lt;= a_{n - 1}$ $3.$ $a_i &lt;= max(a_{i - 1},a_{i + 1})$ ，$i$ 从 $2$ 到 $n - 1$ 问：总共会有多少个不一样的数列 ？ （ $\%998244353$) 数据范围： $2 &lt;=n &lt;= 1e5$ $1 &lt;= a_i &lt;= 200$ $or$ $-1$ 样例：$input$ 1234531 -1 22-1 -1 $output$ 1231200 解题思路： 状态：$dp[i][j][k]$ : 表示在第 $i$ 为放 $j$ 时 [0 : &lt; ] , [1 : = ] , [2 : &gt; ] a[i - 1] 的方案数。 初始化：见代码解释 转移： $dp[i][j][1]$ $=$ $dp[i - 1][j][0]$ $+$ $dp[i - 1][j][1]$ $+$ $dp[i - 1][j][2]$ 。表示第 $i$ 位放 $j$ 时的方案数等于 第 $i - 1$ 位放 $j$ 时大于，等于和小于左边的方案数之和。 $dp[i][j][0]$ 是由第 $i - 1$ 位放 $1 -&gt; (j - 1)$ 大于，等于和小于左边的方案数之和。（转移时满足条件3） $dp[i][j][2]$ 是由第 $i - 1$ 位放 $(j + 1) -&gt; 200$ 等于和小于左边的方案数之和。（转移时满足条件3） AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;const LL mod = 998244353;const int maxn = 1e5 + 5;LL dp[maxn][205][3]; // 表示在第i为放j时 [0 : &lt; ] , [1 : = ] , [2 : &gt; ] 左边的方案数。int a[maxn];int n;void Init()&#123; // 初始化 for(int i = 1;i &lt;= 200;i++)&#123; if(a[1] == -1 || a[1] == i) dp[1][i][0] = 1; // 可以看作加上 a[0] = -inf,a[n + 1] = -inf,所以这样初始化可以满足条件：一定要 a[2] &gt; a[1], a[n - 1] &gt; a[n] 。 else dp[1][i][0] = 0; // 也就是不用管当前位是首位还是尾位了，只要满足 a[i] &lt;= max(a[i - 1],a[i + 1]) 就行。 &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); Init(); LL sum; for(int i = 2;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= 200;j++)&#123; if(a[i] == -1 || a[i] == j) dp[i][j][1] = (dp[i - 1][j][0] + dp[i - 1][j][1] + dp[i - 1][j][2]) % mod; else dp[i][j][1] = 0; &#125; sum = 0LL; for(int j = 1;j &lt;= 200;j++)&#123; // 正着，求前缀和 if(a[i] == -1 || a[i] == j) dp[i][j][0] = sum % mod; else dp[i][j][0] = 0LL; sum = (sum + dp[i - 1][j][1] + dp[i - 1][j][0] + dp[i - 1][j][2]) % mod; &#125; sum = 0LL; for(int j = 200;j &gt;= 1;j--)&#123; if(a[i] == -1 || a[i] == j) dp[i][j][2] = sum % mod; else dp[i][j][2] = 0LL; sum = (sum + dp[i - 1][j][1] + dp[i - 1][j][2]) % mod; &#125; &#125; LL ans = 0LL; for(int i = 1;i &lt;= 200;i++)&#123;// 倒着，求后缀和 if(a[n] == -1 || a[n] == i) ans = (ans + dp[n][i][1] + dp[n][i][2]) % mod; &#125; printf("%lld\n",ans);&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DP计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces - gym - 101873 - G.Water Testing (几何，皮克定理)]]></title>
    <url>%2F2018%2F10%2F28%2FCodeforces%20-%20gym%20-%20101873%20-%20Problem%20G.Water%20Testing%20(%E5%87%A0%E4%BD%95%EF%BC%8C%E7%9A%AE%E5%85%8B%E5%AE%9A%E7%90%86)%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/gym/101873/problem/G 题意：顺时针给你一些点，问由给你的点围起来的多边形内有多少个整数点？ 数据范围： $3 &lt;= n &lt;= 100000$ $-1e6 &lt;= x_i,y_i &lt;= 1e6$ 样例：$input$ 1234540 00 1010 1010 0 $output$ 181 解题思路：模板题 AC代码：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int Max = 2e5+10;typedef long long ll;#define rep(i,s,n) for(ll i=s;i&lt;=n;i++)#define per(i,n,s) for(ll i=n;i&gt;=s;i--)struct node&#123; ll x,y;&#125;p[Max];ll gcd(ll a, ll b)&#123; return b==0 ? a : gcd (b,a%b);&#125;//皮克定理:多边形的面积 = 多边形内部整点的个数 + 边上正点的个数 / 2 - 1；int main()&#123; int n; scanf("%d",&amp;n); rep(i,0,n-1)&#123; scanf("%lld %lld",&amp;p[i].x,&amp;p[i].y); &#125; ll sum=0; rep(i,0,n-1)&#123; sum+=(p[(i+1)%n].y)*(p[i].x-p[(i+2)%n].x); &#125;//这是在求多边形的面积； ll ans=0; rep(i,0,n-1)&#123; ans+=gcd(abs(p[i].x-p[(i+1)%n].x),abs(p[i].y-p[(i+1)%n].y)); &#125;//这是在求边界上面的点 sum=abs(sum); sum=(sum-ans)/2+1; printf("%lld\n",sum); return 0;&#125;]]></content>
      <categories>
        <category>几何</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>皮克定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces - gym - 101873 - F.Plug It In!(二分图匹配）]]></title>
    <url>%2F2018%2F10%2F25%2FCodeforces%20-%20gym%20-%20101873%20-%20F.Plug%20It%20In!(%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/gym/101873/problem/F 题意： 有 $m$ 个电源和 $n$ 个设备。给你 $k$ 对关系 （$x_i$ ，$y_i$ )，表示编号为 $x_i$ 的电源可以为编号为 $y_i$ 的设备供电，现在有一个 $3$ 孔的接线板，可以把一个电源分成 $3$ 个相同的电源。 问：最多可以有几个设备能通电？ 数据范围： $1 &lt;= m,n &lt;= 1500$ $0 &lt;= k &lt;= 75000$ 样例：$input$ 123456789101112131415161718192021222324252627282930313 6 81 11 21 32 32 43 43 53 64 5 111 11 21 32 12 22 33 13 23 34 44 53 5 71 11 22 22 32 43 43 5 $output$ 12345555 解题思路： 一看到题目就应该想到是二分图的最大匹配，但这题多出了一个接线板，可以把一个电源分成三个相同的电源。二分图匹配的最坏复杂度为 O(E V)，而且匹配的过程是编号逐渐从 $1$ 到 $m$ （在这题) ，那么我们就可以先不考虑有接线板，直接匹配得到一个 $ans$ ，把不考虑接线板情况下每个设备接到哪个电源给记下来 $dev[i]$ 。 接着我们开始考虑有接线板的情况。在有接线板的情况下，最大配备数最多会加 $2$ ，那么我就枚举在哪个电源使用借接线板，在新编号 $m +1$ 的电源建跟电源 $i$ 有连线的点的边，和新编号 $m + 2$ 的的电源建跟电源 $i$ 有连线的点的边，继续匹配。看看最多能增加多少设备通电 $add$ 最后的答案：$ans = ans + add$ AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int maxn = 1505;vector&lt;int&gt; G[maxn];bool used[maxn];int dev[maxn];int tmp[maxn];int vis[maxn];int m,n,k,ans,add;bool Find(int x)&#123; for(int i = 0;i &lt; G[x].size();i++)&#123; int y = G[x][i]; if(used[y] == 0)&#123; used[y] = 1; if(dev[y] == 0 || Find(dev[y]))&#123; dev[y] = x; return true; &#125; &#125; &#125; return false;&#125;int Match()&#123; int all = 0; for(int i = 1;i &lt;= m;i++)&#123; memset(used,0,sizeof(used)); if(Find(i)) all++; &#125; return all;&#125;int main()&#123; scanf("%d %d %d",&amp;m,&amp;n,&amp;k); for(int i = 1;i &lt;= k;i++)&#123; int x,y; scanf("%d %d",&amp;x,&amp;y); G[x].push_back(y); vis[x]++; &#125; ans = Match(); add = 0; for(int i = 1;i &lt;= n;i++) tmp[i] = dev[i]; for(int i = 1;i &lt;= m;i++)&#123; if(vis[i] &gt;= 2)&#123; for(int j = 0;j &lt; G[i].size();j++)&#123; int y = G[i][j]; G[m + 1].push_back(y); G[m + 2].push_back(y); &#125; int tot = 0; memset(used,0,sizeof(used)); if(Find(m + 1)) tot++; memset(used,0,sizeof(used)); if(Find(m + 2)) tot++; add = max(add,tot); G[m + 1].clear(); G[m + 2].clear(); for(int i = 1;i &lt;= n;i++) dev[i] = tmp[i]; &#125; if(add == 2) break; &#125; printf("%d\n",ans + add);&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces - gym - 101911 - L.Ray in the tube]]></title>
    <url>%2F2018%2F10%2F19%2FCodeforces%20-%20gym%20-%20101911%20-%20L.Ray%20in%20the%20tube%2F</url>
    <content type="text"><![CDATA[参考博客：http://www.cnblogs.com/--BLUESKY007/p/9660440.html 题目链接：http://codeforces.com/gym/101911/problem/L 题意： 输入 $n$ , $y1$ 代表在 $y = y1$ 这条直线上有 $n$ 个横坐标为 $a_i$ 的点 输入 $m$ , $y2$ 代表在 $y = y2$ 这条直线上有 $m$ 个横坐标为 $b_i$ 的点 问：你可以从任意一个点以任何角度发射一束激光，激光经过反射后最多能经过多少个点？ 如图： 数据范围： $1 &lt;= n,m &lt;= 1e5$ $0 &lt;= y1,y2 &lt;= 1e9$ $0 &lt;= a_i,b_i &lt;= 1e9$ 样例：$input$ 12343 11 5 61 33 $output$ 13 解题思路： 首先我们可以知道当$a_i,b_i$ 确定时，$y1,y2$ 对答案并没有影响，只与激光射入角度有关，也就是与步长有关。 步长：从 $y1$ ($y2$) 发射激光第一次到 $y2$ ($y1$) 的水平距离。 步长我们可以表示为：$2^k * (2p + 1)$ ($k,p∈ 0,1,2….$) , 因为这个式子可以表示任何正整数（也就是正偶数和奇数） 假设 $k = 0,p = 1$ ，画出图形，步长分别为 $1,3$ 我们可以发现步长为 $2^k$ 的激光经过的点可以覆盖所有步长为 $2^k (2p + 1)$ 的激光经过的点，且前者密度更大，所以对于一个为 $2^k (2p + 1)$ 的步长，总有一个步长为 $2^k$ 的最优解存在。 有了上面的结论，我们可以先枚举 $2^k$ 的步长，任何把 $a_i,b_i \% $ $2^{k + 1}$ 映射到 $(0 - 2^{k + 1} - 1)$ 区间里，确定了步长为 $2 ^ k$ 时，那么到下一个点就是 $a_i + 2 ^ k$ 或 $b_i + 2 ^ k$。然后用 $map$ 记录一下对应的点数，最后取个 $max$ 就是答案。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;map&gt;using namespace std;const int maxn = 1e5 + 5;map&lt;long long,int&gt; vis_a;map&lt;long long,int&gt; vis_b;int a[maxn];int b[maxn];int base[35];int n,m,y_1,y_2;int ans;inline void Init()&#123; for(int i = 0;i &lt;= 30;i++)&#123; base[i] = 1 &lt;&lt; i; &#125;&#125;void Solve(int k)&#123; vis_a.clear(),vis_b.clear(); for(int i = 1;i &lt;= n;i++) vis_a[a[i] % base[k + 1]]++; for(int i = 1;i &lt;= m;i++) vis_b[b[i] % base[k + 1]]++; for(int i = 1;i &lt;= n;i++)&#123; ans = max(ans,vis_a[a[i] % base[k + 1]] + vis_b[(a[i] + base[k]) % base[k + 1]]); &#125; for(int i = 1;i &lt;= m;i++)&#123; ans = max(ans,vis_b[b[i] % base[k + 1]] + vis_a[(b[i] + base[k]) % base[k + 1]]); &#125;&#125;int main()&#123; Init(); ans = 2; scanf("%d %d",&amp;n,&amp;y_1); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); scanf("%d %d",&amp;m,&amp;y_2); for(int i = 1;i &lt;= m;i++) scanf("%d",&amp;b[i]); for(int i = 0;i &lt;= 29;i++) Solve(i); printf("%d\n",ans);&#125;]]></content>
      <categories>
        <category>几何</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>几何</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hdu 4578 Transformation(区间加值,区间乘值,区间赋值,查询区间的p次方)]]></title>
    <url>%2F2018%2F10%2F17%2FHDU%204578%20Transformation(%E5%8C%BA%E9%97%B4%E5%8A%A0%E5%80%BC%2C%E5%8C%BA%E9%97%B4%E4%B9%98%E5%80%BC%2C%E5%8C%BA%E9%97%B4%E8%B5%8B%E5%80%BC%2C%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E7%9A%84p%E6%AC%A1%E6%96%B9)%2F</url>
    <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4578 题意：给你一个数组，初始值为零，有四种操作： （1）”1 x y c”,代表 把区间 $[x,y]$ 上的值全部加c。 （2）”2 x y c”,代表 把区间 $[x,y]$ 上的值全部乘以 $c$。 （3）”3 x y c” 代表 把区间 $[x,y]$上的值全部赋值为 $c$。 （4）”4 x y p” 代表 求区间 $[x,y]$ 上值的p次方和 $1&lt;=p&lt;=3$。 样例：$input$ 12345675 53 3 5 71 2 4 44 1 5 22 2 5 84 3 5 30 0 $output$ 123077489 解题思路：首先先解决一个区间内可能同时出现+和的操作的问题(如果出现赋值,则在赋值之前的+和都是无效的),我们可以把加法累计起来,把乘法先处理了,比如说原来 $[l,r]$ 这一段上有了 $+x$ ,现在要求 $y$,我们可以先把原来的每个数乘以y,然后加上 $xy$,即都是先处理乘法,在处理加法。 然后处理一下区间查询的问题,假设原来的值是k,如果是乘法或者赋值的话,$sumv1,sumv2,sumv3$的修改是很容易实现的,如果是加, $(p+k)^3=p^3+3p^2k+3k^2p+k^3$, 所以 $sumv3[rt]=sumv3[rt]+sumv2[rt]3k+sumv1[rt]3k+(r-l+1)*k^3$,同理二次方的修改也是如此 AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;bits/stdc++.h&gt;using namespace std;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1const int maxn=110100;typedef long long ll;const int MOD=10007;ll sumv1[maxn*4],sumv2[maxn*4],sumv3[maxn*4],v,op,setv[maxn*4],mul[4*maxn],addv[4*maxn];int L,R; void build(int l,int r,int rt)&#123; sumv1[rt]=0,sumv2[rt]=0,sumv3[rt]=0; setv[rt]=addv[rt]=mul[rt]=0; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(lson); build(rson);&#125; void pushup(int rt)&#123; sumv1[rt]=(sumv1[rt&lt;&lt;1]+sumv1[rt&lt;&lt;1|1])%MOD; sumv2[rt]=(sumv2[rt&lt;&lt;1]+sumv2[rt&lt;&lt;1|1])%MOD; sumv3[rt]=(sumv3[rt&lt;&lt;1]+sumv3[rt&lt;&lt;1|1])%MOD;&#125; void change(int op,int rt,int l,int r,ll k)&#123; if(op==1)&#123; sumv3[rt]=(sumv3[rt]+sumv2[rt]*3*k+3*k*k*sumv1[rt]%MOD+k*k*k%MOD*(r-l+1))%MOD; sumv2[rt]=(sumv2[rt]+k*k*(r-l+1)+2*k*sumv1[rt])%MOD; sumv1[rt]=(sumv1[rt]+k*(r-l+1))%MOD; &#125; else if(op==2)&#123; sumv3[rt]=sumv3[rt]*(k*k*k%MOD)%MOD; sumv2[rt]=sumv2[rt]*k*k%MOD; sumv1[rt]=sumv1[rt]*k%MOD; &#125; else&#123; sumv3[rt]=(k*k*k%MOD)*(r-l+1)%MOD; sumv2[rt]=k*k*(r-l+1)%MOD; sumv1[rt]=k*(r-l+1)%MOD; &#125;&#125; void pushdown(int rt,int l,int r)&#123; if(setv[rt]!=0)&#123; int mid=(l+r)&gt;&gt;1; change(3,rt&lt;&lt;1,l,mid,setv[rt]); change(3,rt&lt;&lt;1|1,mid+1,r,setv[rt]); setv[rt&lt;&lt;1]=setv[rt&lt;&lt;1|1]=setv[rt]; addv[rt&lt;&lt;1]=addv[rt&lt;&lt;1|1]=0; mul[rt&lt;&lt;1]=mul[rt&lt;&lt;1|1]=0; setv[rt]=0; &#125; if(mul[rt]!=0)&#123; int mid=(l+r)&gt;&gt;1; change(2,rt&lt;&lt;1,l,mid,mul[rt]); change(2,rt&lt;&lt;1|1,mid+1,r,mul[rt]); if(mul[rt&lt;&lt;1]==0) mul[rt&lt;&lt;1]=mul[rt]; else mul[rt&lt;&lt;1]=mul[rt&lt;&lt;1]*mul[rt]%MOD; if(mul[rt&lt;&lt;1|1]==0) mul[rt&lt;&lt;1|1]=mul[rt]; else mul[rt&lt;&lt;1|1]=mul[rt&lt;&lt;1|1]*mul[rt]%MOD; addv[rt&lt;&lt;1]=addv[rt&lt;&lt;1]*mul[rt]%MOD; addv[rt&lt;&lt;1|1]=addv[rt&lt;&lt;1|1]*mul[rt]%MOD; mul[rt]=0; &#125; if(addv[rt]!=0)&#123; int mid=(l+r)&gt;&gt;1; change(1,rt&lt;&lt;1,l,mid,addv[rt]); change(1,rt&lt;&lt;1|1,mid+1,r,addv[rt]); addv[rt&lt;&lt;1]=(addv[rt&lt;&lt;1]+addv[rt])%MOD; addv[rt&lt;&lt;1|1]=(addv[rt&lt;&lt;1|1]+addv[rt])%MOD; addv[rt]=0; &#125;&#125; void update(int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; if(op==3)&#123; setv[rt]=v,mul[rt]=0,addv[rt]=0; change(op,rt,l,r,v); &#125; else if(op==2)&#123; if(mul[rt]==0) mul[rt]=v; else mul[rt]=mul[rt]*v%MOD; addv[rt]=addv[rt]*v%MOD; change(op,rt,l,r,v); &#125; else&#123; addv[rt]=(addv[rt]+v)%MOD; change(op,rt,l,r,v); &#125; return ; &#125; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(lson); if(R&gt;mid) update(rson); pushup(rt);&#125; ll query(int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;R&gt;=r)&#123; if(v==1) return sumv1[rt]; if(v==2) return sumv2[rt]; return sumv3[rt]; &#125; pushdown(rt,l,r); int mid=(l+r)&gt;&gt;1; ll ans=0; if(L&lt;=mid) ans+=query(lson); if(R&gt;mid) ans+=query(rson); return ans;&#125; int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; if(n==0&amp;&amp;m==0) break; build(1,n,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d%lld",&amp;op,&amp;L,&amp;R,&amp;v); if(op==4) printf("%lld\n",query(1,n,1)%MOD); else update(1,n,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deque(双端队列)]]></title>
    <url>%2F2018%2F10%2F17%2FDeque(%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97)%2F</url>
    <content type="text"><![CDATA[声明deque容器123456#include&lt;deque&gt; // 头文件deque&lt;type&gt; deq; // 声明一个元素类型为type的双端队列quedeque&lt;type&gt; deq(size); // 声明一个类型为type、含有size个默认值初始化元素的的双端队列quedeque&lt;type&gt; deq(size, value); // 声明一个元素类型为type、含有size个value元素的双端队列quedeque&lt;type&gt; deq(mydeque); // deq是mydeque的一个副本deque&lt;type&gt; deq(first, last); // 使用迭代器first、last范围内的元素初始化deq deque的常用成员函数123456789deque&lt;int&gt; deq;deq[ ]：用来访问双向队列中单个的元素。deq.front()：返回第一个元素的引用。deq.back()：返回最后一个元素的引用。deq.push_front(x)：把元素x插入到双向队列的头部。deq.pop_front()：弹出双向队列的第一个元素。deq.push_back(x)：把元素x插入到双向队列的尾部。deq.pop_back()：弹出双向队列的最后一个元素。]]></content>
      <categories>
        <category>双端队列</category>
      </categories>
      <tags>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces - gym - 101808 - I. Ildar Yalalov (博弈，dp)]]></title>
    <url>%2F2018%2F10%2F02%2FCodeforces%20-%20gym%20-%20101808%20-%20I.%20Ildar%20Yalalov%20(%E5%8D%9A%E5%BC%88%EF%BC%8Cdp)%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/gym/101808/problem/I 题意：T 组数据 有 $n$ 堆石子，第 $i$ 堆有 $A_i$ 个石子，$Yalalov$ 和 $Shin$ 两人轮流拿，总共有 $2$ 种操作： 选任意一堆石子，拿走这堆石子中的一个石子。 拿走每一堆石子中的一个石子（当所有堆石子个数大于等于 $1$ 时，才能选择此操作） 如果当前轮，拿不了石子时，处在当前轮的人算输。 问：当 $Yalalov$ 先手时，最后谁赢？ 数据范围： $1 ≤ N ≤ 100$ $1 ≤ A_i ≤ 10^6$ 样例：$input$ 123121 2 $output$ 1Yalalov 解题思路：这道题可以看做两部分： 上部分 下部分 所以状态为： $dp[maxn][5]$ ; 底下为i层，上面石子总数为0，奇数，偶数时的获胜状态。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;#define pb push_back#define debug(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl#define rep(i,a,n) for(int i = a;i &lt;= n;i++)#define per(i,n,a) for(int i = n;i &gt;= a;i--)const int INF_INT = 0x3f3f3f3f;const long long INF_LL = 0x7fffffff;const int maxn = 1e6 + 5;int dp[maxn][5]; // 底下为i层，上面石子总数为0，奇数，偶数时的获胜状态。int a[105];int n;/*22 3 11 11 1*/int Get(int x)&#123; if(!x) return 0; return x &amp; 1 == 1 ? 1 : 2;&#125;int Solve(int deep,int x)&#123; // 把所有状态转移都写出来，也就是看下一层是否有必败态。 if(dp[deep][x] != 0) return dp[deep][x]; dp[deep][x] = 1; // 初始都为必败态，只要下面有一个必败态就赢。 if(deep - 1 &gt;= 0)&#123; if(Solve(deep - 1,x) == 1) dp[deep][x] = 2; int tmp = x + n - 1; if(Solve(deep - 1,Get(tmp)) == 1) dp[deep][x] = 2; &#125; if(x &gt; 0) if(Solve(deep,x - 1) == 1) dp[deep][x] = 2; return dp[deep][x];&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int mi = maxn, tot = 0; scanf("%d",&amp;n); rep(i,1,n) scanf("%d",&amp;a[i]), mi = min(mi,a[i]); dp[0][0] = 1, dp[0][1] = 2, dp[0][2] = 1; rep(i,1,n) tot += a[i] - mi; Solve(mi,Get(tot)) == 2 ? printf("Yalalov\n") : printf("Shin\n"); rep(i,0,mi) rep(j,0,2) dp[i][j] = 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>DP</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hiho - 1828 - Saving Tang Monk II(状态，最短路)]]></title>
    <url>%2F2018%2F10%2F02%2Fhiho%20-%201828%20-%20%20Saving%20Tang%20Monk%20II(%E7%8A%B6%E6%80%81%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF)%2F</url>
    <content type="text"><![CDATA[题目链接：http://hihocoder.com/problemset/problem/1828 题意： 给你一个 $N * M$ 的矩阵 矩阵里总共有 $6$ 个符号 $S$ , $T$ , $.$ , $#$ , $B$ , $P$ $S$ : 出发的位置 $T$ : 终点的位置 $.$ : 可以走的位置 $#$ : 有毒气的位置 $B$ : 拥有氧气的位置 $P$ : 拥有加速卡的位置 经过 $.$ , $B$ 花费 $1$ 秒 经过 $P$ 花费 $0$ 秒 经过 $#$ 花费 $2$ 秒，和消耗一瓶氧气，经过此处必须至少携带一瓶氧气 问：在最多只能同时携带 $5$ 瓶氧气的条件下，从 $S$ 到 $T$ 最少需要花费多少秒？ 数据范围： $0 &lt; N,M ≤ 100$ 最多 $25$ 组样例 样例：$input$ 12345678910111213142 2S##T2 5SB#####P#T4 7SP.....P#...........#B...##T0 0 $output$ 123-1811 解题思路：因为最多只能同时携带 $5$ 瓶氧气，所以我们可以想到这个状态： $dis[i][j][k]$ : 从 $S$ 出发到 $(i,j)$ ,携带 $k$ 瓶氧气时，最少花费时间（最短距离）是多少？ 然后我们就跑一个最短路就行。下面是跑 $spfa$ 的代码。（转移见代码） 最后答案氧气从 $0$ ~ $5$ 取个最小值。 其实，跑最短路也是一个状态转移的过程，所以碰到此类题时，可以先想想每一个点的状态可以这么表示。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int inf = 1 &lt;&lt; 29;const int maxn = 105;int dis[maxn][maxn][6];char s[maxn][maxn];int n,m,Sx,Sy,Tx,Ty;bool vis[maxn][maxn];struct NODE&#123; int x,y; NODE () &#123;&#125; NODE (int _x,int _y)&#123; x = _x; y = _y; &#125;&#125;;void Init()&#123; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= m;j++)&#123; for(int sta = 0;sta &lt;= 5;sta++)&#123; dis[i][j][sta] = inf; &#125; &#125; &#125; dis[Sx][Sy][0] = 0;&#125;bool Check(int nx,int ny)&#123; if(nx &lt;= 0 || ny &lt;= 0 || nx &gt; n || ny &gt; m) return false; return true;&#125;void Spfa()&#123; queue&lt;NODE&gt; seq; seq.push(NODE(Sx,Sy)); while(!seq.empty())&#123; NODE now = seq.front(); seq.pop(); vis[now.x][now.y] = 0; for(int i = -1;i &lt;= 1;i++)&#123; for(int j = -1;j &lt;= 1;j++)&#123; int nx = now.x + i; int ny = now.y + j; if(i == 0 &amp;&amp; j == 0) continue; if(Check(nx,ny) &amp;&amp; i * j == 0)&#123; if(s[nx][ny] == 'P')&#123; for(int sta = 0;sta &lt;= 5;sta++)&#123; if(dis[nx][ny][sta] &gt; dis[now.x][now.y][sta])&#123; dis[nx][ny][sta] = dis[now.x][now.y][sta]; if(!vis[nx][ny])&#123; vis[nx][ny] = 1; seq.push(NODE(nx,ny)); &#125; &#125; &#125; &#125; else if(s[nx][ny] == '#')&#123; for(int sta = 0;sta &lt;= 4;sta++)&#123; if(dis[nx][ny][sta] &gt; dis[now.x][now.y][sta + 1] + 2)&#123; dis[nx][ny][sta] = dis[now.x][now.y][sta + 1] + 2; if(!vis[nx][ny])&#123; vis[nx][ny] = 1; seq.push(NODE(nx,ny)); &#125; &#125; &#125; &#125; else if(s[nx][ny] == '.' || s[nx][ny] == 'S' || s[nx][ny] == 'T')&#123; for(int sta = 0;sta &lt;= 5;sta++)&#123; if(dis[nx][ny][sta] &gt; dis[now.x][now.y][sta] + 1)&#123; dis[nx][ny][sta] = dis[now.x][now.y][sta] + 1; if(!vis[nx][ny])&#123; vis[nx][ny] = 1; seq.push(NODE(nx,ny)); &#125; &#125; &#125; &#125; else if(s[nx][ny] == 'B')&#123; for(int sta = 0;sta &lt;= 4;sta++)&#123; if(dis[nx][ny][sta + 1] &gt; dis[now.x][now.y][sta] + 1)&#123; dis[nx][ny][sta + 1] = dis[now.x][now.y][sta] + 1; if(!vis[nx][ny])&#123; vis[nx][ny] = 1; seq.push(NODE(nx,ny)); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;n,&amp;m))&#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 1;j &lt;= m;j++)&#123; scanf(" %c",&amp;s[i][j]); if(s[i][j] == 'S') Sx = i, Sy = j; if(s[i][j] == 'T') Tx = i, Ty = j; &#125; &#125; Init(); Spfa(); int mi = inf; for(int i = 0;i &lt;= 5;i++) mi = min(mi,dis[Tx][Ty][i]); if(mi == inf) printf("-1\n"); else printf("%d\n",mi); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ - 2104 - K-th Number(区间第k大)]]></title>
    <url>%2F2018%2F10%2F02%2FPOJ%20-%202104%20-%20K-th%20Number(%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7)%2F</url>
    <content type="text"><![CDATA[题目链接：http://poj.org/problem?id=2104 题意：求区间第 $k$ 大 数据范围： $1 &lt;= n &lt;= 100 000$ $1 &lt;= m &lt;= 5 000$ $1 &lt;= i &lt;= j &lt;= n$ $1 &lt;= k &lt;= j - i + 1$ 样例：$input$ 123457 31 5 2 6 3 7 42 5 34 4 11 7 3 $output$ 123563 AC 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;const int INF_INT = 0x3f3f3f3f;const long long INF_LL = 0x7fffffff;#define pb push_back#define debug(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl#define rep(i,a,n) for(int i = a;i &lt;= n;i++)#define per(i,n,a) for(int i = n;i &gt;= a;i--)inline void OPEN(string s)&#123; freopen((s + ".in").c_str(), "r", stdin); freopen((s + ".out").c_str(), "w", stdout);&#125;const int maxn = 1e5 + 6;int n,m,cnt,root[maxn],a[maxn],x,y,k;struct node&#123;int l,r,sum;&#125; T[maxn * 40];vector&lt;int&gt; v;int getid(int x) &#123;return lower_bound(v.begin(),v.end(),x) - v.begin() + 1;&#125; //找出第一个大于等于 x 的下标 + 1void update(int l,int r,int &amp;x,int y,int pos)&#123; // y 是上一个线段树对应的节点 T[++cnt] = T[y], T[cnt].sum++, x = cnt; // 上一个节点指向下一个新节点 if(l == r) return; int mid = (l + r) &gt;&gt; 1; if(mid &gt;= pos) update(l,mid,T[x].l,T[y].l,pos); else update(mid + 1,r,T[x].r,T[y].r,pos);&#125;int query(int l,int r,int x,int y,int k)&#123; if(l == r) return l; int mid = (l + r) &gt;&gt; 1; int sum = T[T[y].l].sum - T[T[x].l].sum; if(sum &gt;= k) return query(l,mid,T[x].l,T[y].l,k); else return query(mid + 1,r,T[x].r,T[y].r,k - sum);&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); rep(i,1,n) scanf("%d",&amp;a[i]), v.pb(a[i]); sort(v.begin(),v.end()), v.erase(unique(v.begin(),v.end()),v.end()); rep(i,1,n) update(1,n,root[i],root[i - 1],getid(a[i])); rep(i,1,m)&#123; scanf("%d %d %d",&amp;x,&amp;y,&amp;k); printf("%d\n",v[query(1,n,root[x - 1],root[y],k) - 1]); &#125; return 0;&#125;//对数据离散化后,每个节点维护对应离散化后值区间的数的总个数size。自上至下进行询问操作时，判断当前点左子树的size与要查询的排名k的大小关系。如果小于等于，就到左子树中找，k不变。否则到右子树中找排名k−size的值。//权值线段树每一个节点,记录的是在当前时刻 [值l 到 值r] 的总个数.//建 n 个权值线段树,第 i 个权值线段树记录 1 ~ i 时刻 [值l 到 值r] 的总个数,相当于是前缀和//区间[L,R] 中 [值l 到 值r] 的总个数,答案 = 第 R 个权值线段树代表 [值l 到 值r] 的节点 - 第 L 个权值线段树代表 [值l 到 值r] 的节点.//因为这些线段树都是完全相等的,都会有对应的节点,所以可以直接相减.]]></content>
      <categories>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>区间第k大</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产生随机数]]></title>
    <url>%2F2018%2F09%2F25%2F%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[12345#include&lt;ctime&gt;srand(time(NULL));int a = (1.0 * rand() / RAND_MAX) * n + 1;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弦图与区间图]]></title>
    <url>%2F2018%2F09%2F15%2F%E5%BC%A6%E5%9B%BE%E4%B8%8E%E5%8C%BA%E9%97%B4%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[诱导子图：若选择了某些点，要把在原图上与这些点有相连的边都包含。 团：是G的一个子图，完全图，也就是两两点有连边。 极大团：不是其它团的子集。 最大团 W(G)：顶点最多的极大团。 最小染色 X(G):用最少的颜色给点染色使得相邻点颜色不同。 最大独立集 α(G)：最大的一个点的子集使得任何两个点不相邻。 最小团覆盖 K(G)：用最少个数的团覆盖所有的点。 W(G) &lt;= X(G) (普通图)α(G) &lt;= K(G) (普通图)W(G) == X(G) (弦图) 最大团数 = 最小色数α(G) == K(G) (弦图) 最大独立集 = 最小团覆盖弦：连接环中不相邻的两个点的边。 弦图：一个无向图称为弦图，当图中任意长度大于3的环都至少有一个弦。 单纯点：若一个点加上它相邻的点的诱导子图为一个团，则这个点为单纯点。 引理：任何一个弦图都至少有一个单纯点，不是完全图的弦图至少有两个不相邻的单纯点。 完美消除序列：对与序列中的点vi，排在vi后面并且和vi相连的点是一个团 定理：一个无向图是弦图当且仅当它有一个完美消除序列。 完美消除序列的作用：求弦图的最大团数/最小色数的时候，只要在完美消除序列上从后往前贪心染色即可。 而求最大独立集/最小团覆盖的时候，只要在完美消除序列上从前往后贪心取点即可。]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[后缀数组-出现次数大于等于k次的子串种类(String and Times)]]></title>
    <url>%2F2018%2F09%2F15%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Ek%E6%AC%A1%E7%9A%84%E5%AD%90%E4%B8%B2%E7%A7%8D%E7%B1%BB(String%20and%20Times)%2F</url>
    <content type="text"><![CDATA[题目链接：https://nanti.jisuanke.com/t/31717 题意：给你一个字符串 $S$ ，问字符串 $S$ 中有多少种子串出现（可重叠）次数在 $[A,B]$ ？ 样例：$input$ 12AAA 2 3ABAB 2 2 $output$ 1223 数据范围： $∑length(S)≤2×106$ $1 \le A \le B \le length(S)$ 单组字符串长度不超过 $1e5$ 解题思路：答案 $=$ 出现次数大于等于 $A$ 次的种类 - 出现次数大于 $B$ 次的种类 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2e5 + 10;int w[maxn], r[maxn * 2], cnt[maxn * 2];char s[maxn];int root,last;int all; //总结点int l; //字符串长度struct sam_node&#123; int fa,son[26]; int len; void init(int _len)&#123; len = _len; fa = -1; memset(son,-1,sizeof(son)); &#125;&#125;t[maxn * 2];void sam_init()&#123; all = 0; root = last = 0; t[all].init(0);&#125;void extend(int w)&#123; int p = last; int np = ++all; t[all].init(t[p].len + 1); int q,nq; while(p != -1 &amp;&amp; t[p].son[w] == -1)&#123; t[p].son[w] = np; p = t[p].fa; &#125; if(p == -1) t[np].fa = root; else&#123; q = t[p].son[w]; if(t[p].len + 1 == t[q].len) t[np].fa = q; else&#123; nq = ++all; t[nq].init(0); t[nq] = t[q]; t[nq].len = t[p].len + 1; t[q].fa = nq; t[np].fa = nq; while(p != -1 &amp;&amp; t[p].son[w] == q)&#123; t[p].son[w] = nq; p = t[p].fa; &#125; &#125; &#125; last = np;&#125;void Solve()&#123; for(int i = 0; i &lt;= l; ++i) w[i] = 0; for(int i = 1; i &lt;= all; ++i) w[t[i].len]++; for(int i = 1; i &lt;= l; ++i) w[i] += w[i-1]; for(int i = all; i &gt;= 1; --i) r[w[t[i].len]--] = i; r[0] = 0;&#125;int main()&#123; int n, A, B, p; while(~scanf("%s %d %d",&amp;s,&amp;A,&amp;B))&#123; int tl = strlen(s); l = 0; sam_init(); for(int i = 0; i &lt; tl; ++i)&#123; ++l; s[i] = s[i] + 32; // 这里规定输入的字符只有大写字母。 extend(s[i] - 'a'); &#125; for(int i = 0; i &lt;= all; ++i) cnt[i] = 0; Solve(); p = root; for(int i = 0; i &lt; l; ++i)&#123; p = t[p].son[s[i] - 'a']; cnt[p]++; &#125; for(int i = all; i &gt;= 1; --i)&#123; p = r[i]; if(t[p].fa != -1)&#123; cnt[t[p].fa] += cnt[p]; &#125; &#125; LL ans1 = 0, ans2 = 0; for(int i = 1; i &lt;= all; ++i)&#123; if(cnt[i] &gt;= A) ans1 += t[i].len-t[t[i].fa].len; // 计算出现次数大于等于A的种类 &#125; for(int i = 1; i &lt;= all; ++i)&#123; if(cnt[i] &gt; B) ans2 += t[i].len-t[t[i].fa].len; // 计算出现次数大于B的种类 &#125; printf("%lld\n", ans1 - ans2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SG函数模板]]></title>
    <url>%2F2018%2F09%2F12%2FSG%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[模板一：12345678910111213141516171819//f[]：可以取走的石子个数//sg[]:0~n的SG函数值//hash[]:mex&#123;&#125;int f[K],sg[N],hash[N];void getSG(int n)&#123; memset(sg,0,sizeof(sg)); for(int i=1; i&lt;=n; i++) &#123; memset(hash,0,sizeof(hash)); for(int j=0; f[j]&lt;=i &amp;&amp; j &lt; k; j++) //k是f[]的有效长度 hash[sg[i-f[j]]]=1; for(int j=0; ; j++) &#123; //求mes&#123;&#125;中未出现的最小的非负整数 if(hash[j]==0) &#123; sg[i]=j; break; &#125; &#125; &#125;&#125; 模板二：1234567891011121314151617181920//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍//n是集合s的大小 S[i]是定义的特殊取法规则的数组int s[N],sg[N],n;int getSG(int x)&#123; if(sg[x]!=-1) return sg[x]; bool vis[M]; memset(vis,0,sizeof(vis)); for(int i=0; i&lt;n; i++) &#123; if(x&gt;=s[i]) vis[getSG(x-s[i])]=1; &#125; for(i=0;; i++) if(!vis[i]) &#123; sg[x]=i; break; &#125; return sg[x];&#125;]]></content>
      <categories>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>博弈</tag>
        <tag>SG函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ-2084-[Poi2010]Antisymmetry(回文自动机)]]></title>
    <url>%2F2018%2F09%2F11%2FBZOJ-2084-%5BPoi2010%5DAntisymmetry(%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA)%2F</url>
    <content type="text"><![CDATA[题目链接：https://www.lydsy.com/JudgeOnline/problem.php?id=2084 题意： 输入一个长度为 $n$ 的字符串 $S$ 定义反对称：对于一个 $01$ 字符串，如果将这个字符串 $0$ 和 $1$ 取反后，再将整个串反过来和原串一样，就称作“反对称”字符串。比如 $00001111$ 和 $010101$ 就是反对称的，$1001$ 就不是。 问：它有多少个子串是反对称的？ 数据范围： $n \leq 5e^5$ 样例：$input$ 12811001011 $output$ 17 $hint$ 17个反对称子串分别是：01(出现两次), 10(出现两次), 0101, 1100和001011 解题思路： 所谓的反对称，其实就是：对称位置为 [0,1] 或 [1,0]。不过要注意的一点是一个字符不算反对称。 然后就可以使用回文自动机求解了。 要注意的是因为一个字符不算反对称，也就是说只要是长度为奇数的子串一定不是反对称。所以回文树上我们就可以不要长度为奇数的节点了。也就是，回溯时碰到节点1就不再往下做了。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;typedef unsigned long long ULL;#define pb push_back#define debug(x) cout &lt;&lt; #x &lt;&lt; "=" &lt;&lt; x &lt;&lt; endl#define rep(i,a,n) for(int i = a;i &lt;= n;i++)#define per(i,n,a) for(int i = n;i &gt;= a;i--)const int INF_INT=0x3f3f3f3f;const long long INF_LL=0x7fffffff; inline void OPEN(string s)&#123; freopen((s + ".in").c_str(), "r", stdin); freopen((s + ".out").c_str(), "w", stdout);&#125; const int maxn = 5e5 + 5;char s[maxn + 5];int len; struct PalindromeAutomaton&#123; int ch[maxn][5], fail[maxn], len[maxn], cnt[maxn], tot, lst; PalindromeAutomaton()&#123; tot = 1; fail[0] = fail[1] = 1; len[1] = -1; &#125; inline void extend(int c,int n)&#123; int p = lst; while(n - len[p] - 1 != n &amp;&amp; (n - len[p] - 1 &lt;= 0 || s[n - len[p] - 1] == s[n]))&#123; p = fail[p]; &#125; if(p == 1) &#123;lst = 0;return;&#125; if(!ch[p][c])&#123; int now = ++tot,k = fail[p]; len[now] = len[p] + 2; while(n - len[k] - 1 != n &amp;&amp; (n - len[k] - 1 &lt;= 0 || s[n - len[k] - 1] == s[n])) k = fail[k]; fail[now] = ch[k][c]; ch[p][c] = now; &#125; lst = ch[p][c]; cnt[lst]++; &#125; inline LL solve()&#123; LL ans = 0; per(i,tot,1)&#123; cnt[fail[i]] += cnt[i]; ans += cnt[i]; &#125; return ans; &#125;&#125; pam; int main()&#123; scanf("%d",&amp;len); scanf("%s",s + 1); rep(i,1,len) pam.extend(s[i] - '0' + 2,i); printf("%lld\n",pam.solve()); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BE, GE or NE(DP,博弈)]]></title>
    <url>%2F2018%2F09%2F10%2FBE%2C%20GE%20or%20NE(dp%2C%E5%8D%9A%E5%BC%88)%2F</url>
    <content type="text"><![CDATA[题目链接：https://nanti.jisuanke.com/t/31454 题目大意：有两个人在玩游戏，他们最开始有积分 $m$ 分，如果最终的积分 $val&gt;=k$，则进入 $Bad Ending$，如果最终积分 $val&lt;l$ 则进入 $Good Ending$。现在一共有 $n$ 个关卡，每个选项有三个选项 $a,b,c$，$a$ 代表使得积分 $+a$，$b$ 代表使得积分 $+b$，$c==1$ 代表使得积分 $*(-1)$。如果 $a$ 或$ b$ 等于 $0$ ，则不能选择，题目保证 $a$，$b$，$c$ 不同时为$0$，$A$ 先选，$B$ 后选，$A$ 想要进入 $GE$，$B$ 想要进入 $BE$，他们都会进行最优的操作，问你最后的结局。 数据范围：$1 \leq n \leq 10^3$ $-100 \leq m,k,l \leq 100$ $0 \leq a,b $ $0 \leq c \leq 1$ 样例：$input$ 12343 -8 5 -53 1 12 0 10 2 1 $output$ 1Good Ending $input$ 12343 0 10 30 0 10 10 10 2 1 $output$ 1Bad Ending 解题思路：因为要满足 $GE$，分数越高越好，而要满足 $BE$，分数越低越好，因此 $A$ 的策略应当是取尽可能大的，$B$ 的策略应当是取尽可能小的。从后往前推。 状态方程：$dp[i][j]$ 代表在第 $i$ 个关卡中，分数为 $j$ 分时，选择操作后，最后所能获得的最大的分数。 初始化：$dp[n + 1][i] = i$ 至于为什么自己举一个只有一轮的例子模拟一下就知道了。 转移方程： 见代码 而对于 $i$ 为奇数情况下是 $A$ 选，则 $i$ 的状态要优先选最大值；而对于 $i$ 为偶数的情况下 $B$ 选，则优先选最小。 最后答案：判断 $dp[1][m]$ 满足什么条件后输出相应的答案。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;#define pb push_back#define debug(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl#define rep(i,a,n) for(int i = a;i &lt;= n;i++)#define per(i,n,a) for(int i = n;i &gt;= a;i--)const int INF_INT = 0x3f3f3f3f;const long long INF_LL = 0x7fffffff;const int maxn = 1005;int a[maxn],b[maxn],c[maxn];int dp[maxn][405];const int bits = 100;int main()&#123; int n,m,k,l; scanf("%d %d %d %d",&amp;n,&amp;m,&amp;k,&amp;l); rep(i,1,n) scanf("%d %d %d",&amp;a[i],&amp;b[i],&amp;c[i]); rep(i,0,200) dp[n + 1][i] = i - 100; per(i,n,1)&#123; rep(j,0,200)&#123; int k1 = dp[i + 1][min(200,j + a[i])]; int k2 = dp[i + 1][max(0,j - b[i])]; int k3 = dp[i + 1][200 - j]; if(i &amp; 1)&#123; // max dp[i][j] = -100; if(a[i]) dp[i][j] = max(dp[i][j],k1); if(b[i]) dp[i][j] = max(dp[i][j],k2); if(c[i]) dp[i][j] = max(dp[i][j],k3); &#125; else&#123; // min dp[i][j] = 100; if(a[i]) dp[i][j] = min(dp[i][j],k1); if(b[i]) dp[i][j] = min(dp[i][j],k2); if(c[i]) dp[i][j] = min(dp[i][j],k3); &#125; &#125; &#125; if(dp[1][m + 100] &gt;= k) printf("Good Ending\n"); else if(dp[1][m + 100] &lt;= l) printf("Bad Ending\n"); else printf("Normal Ending\n"); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文自动机]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[参考博客： https://ksmeow.moe/palindromic_tree/ https://blog.csdn.net/u013368721/article/details/42100363 截图： 题目链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3676 题意： 给你一个只由小写字母构成的字符串 $S$ 问 ：字符串 $S$ 中每一个不同回文串出现的次数乘长度之和为多少？ 数据范围： $ 1 \leq |S| \leq 3e^5$ 样例：$input$ 1abacaba $output$ 17 $input$ 1www $output$ 14 $hint$ 123456789101112131415161718192021222324252627一个串是回文的，当且仅当它从左到右读和从右到左读完全一样。 在第一个样例中，回文子串有7个：a，b，c，aba，aca，bacab，abacaba，其中： ● a出现4次，其出现值为4：1：1=4 ● b出现2次，其出现值为2：1：1=2 ● c出现1次，其出现值为l：1：l=l ● aba出现2次，其出现值为2：1：3=6 ● aca出现1次，其出现值为1=1：3=3 ● bacab出现1次，其出现值为1：1：5=5 ● abacaba出现1次，其出现值为1：1：7=7 故最大回文子串出现值为7。 xxxxxxxxxx 一个串是回文的，当且仅当它从左到右读和从右到左读完全一样。 在第一个样例中，回文子串有7个：a，b，c，aba，aca，bacab，abacaba，其中：​● a出现4次，其出现值为4：1：1=4 ​● b出现2次，其出现值为2：1：1=2 ​● c出现1次，其出现值为l：1：l=l ​● aba出现2次，其出现值为2：1：3=6 ​● aca出现1次，其出现值为1=1：3=3 ​●bacab出现1次，其出现值为1：1：5=5 ​● abacaba出现1次，其出现值为1：1：7=7 ​故最大回文子串出现值为7。 www 解题思路：回文自动机 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef unsigned long long ULL;#define pb push_back#define debug(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl#define rep(i,a,n) for(int i = a;i &lt;= n;i++)#define per(i,n,a) for(int i = n;i &gt;= a;i--)const int INF_INT = 0x3f3f3f3f;const long long INF_LL = 0x7fffffff;const int maxn = 3e5 + 5;int n;char s[maxn];struct PalindromAutomaton&#123; //每个节点代表一个不同的回文串 int ch[maxn][26], fail[maxn], len[maxn], cnt[maxn], tot, lst; //ch[i][j] : 表示节点 i 有一条 j 边指向的节点 //fail[i]: 表示节点 i 失配后跳转的节点 //len[i] : 表示节点 i 所代表的回文串的长度 //cnt[i] : 表示节点 i 所代表的回文串出现的次数(建树时求出的不是完全的，最后需要倒着跑一遍以后 才是正确的) //tot : 表示总共节点数 //lst : 表示上一次匹配到的节点 PalindromAutomaton()&#123; tot = 1; fail[0] = fail[1] = 1; len[1] = -1; &#125; inline void extend(int c, int n)&#123; int p = lst; while(s[n - len[p] - 1] != s[n]) p = fail[p]; if(!ch[p][c])&#123; // 若ch[p][c]不存在, 表示会形成一个新的回文串 int now = ++tot, k = fail[p]; len[now] = len[p] + 2; cnt[now]++; while(s[n - len[k] - 1] != s[n]) k = fail[k]; fail[now] = ch[k][c]; ch[p][c] = now; &#125; lst = ch[p][c]; &#125; inline int solve()&#123; int ans = 0; per(i,tot,1) cnt[fail[i]] += cnt[i]; rep(i,1,tot) ans = max(ans,cnt[i] * len[i]); return ans; &#125;&#125;pam;int main()&#123; scanf("%s",s + 1); n = strlen(s + 1); rep(i,1,n) pam.extend(s[i] - 'a',i); printf("%d\n",pam.solve()); return 0;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder-C-String Coloring(字符串)]]></title>
    <url>%2F2018%2F07%2F15%2FAtCoder-C-String%20Coloring(%E5%AD%97%E7%AC%A6%E4%B8%B2)%2F</url>
    <content type="text"><![CDATA[题意： 输入 $n$ 和 字符串 $s$ ，代表 字符串 $s$ 的长度为 $2 * n$ 正着选 $n$ 个字符构成一个字符串 $s1$ ，然后倒着选 $n$ 个字符构成一个字符串 $s2$ ，不能选重复的字符。 问：字符串 $s1$ 与 字符串 $s2$ 完全一样的的方案数是多少？ 数据范围： $1 &lt;= n &lt;= 18$ 字符串 $s$ 都是小写字母 输入：123454cabaacba18aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 输出：1234549075135300[The answer may not be representable as a 32-bit integer.] 样例解释：$There are four ways to paint the string, as follows:$ [c] a b a [a] c [b] [a] [c] a b [a] a c [b] [a] c [a] [b] [a] a [c] b a c [a] [b] a [a] [c] b a 解题思路：因为字符串长度最大为36，那么我们可以先分成两半，然后二进制暴力枚举。0 代表倒着的，1 代表正着的。然后要相互对称。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;typedef long long LL;map&lt;pair &lt;string,string&gt;,LL&gt; cnt;const int maxn = 50;char s[maxn];int main()&#123; int n; scanf("%d",&amp;n); scanf("%s",s); for(int i = 0;i &lt; (1 &lt;&lt; n);i++)&#123; // 先枚举左半边 string s1 = "",s2 = ""; for(int j = 0;j &lt; n;j++)&#123; if(i &amp; (1 &lt;&lt; j)) s1 += s[j]; // 若 i 的第 j 位为 1，则 s[j] 加入 s1. else s2 += s[j]; // 若 i 的第 j 位为 0，则 s[j] 加入 s2. &#125; cnt[make_pair(s1,s2)]++; // 开个 map 来记录有（s1，s2）有多少对 &#125; LL sum = 0; for(int i = 0;i &lt; (1 &lt;&lt; n);i++)&#123; // 枚举右半边 string s1 = "",s2 = ""; for(int j = n - 1;j &gt;= 0;j--)&#123; if(i &amp; (1 &lt;&lt; j)) s2 += s[j + n]; // 若 i 的第 j 位为 1，则 s[j + n] 加入 s2. else s1 += s[j + n]; // 若 i 的第 j 位为 0，则 s[j + n] 加入 s1. &#125; sum += cnt[make_pair(s1,s2)]; // 因为 s1 和 s2 要相等所以要对称相等 &#125; printf("%lld\n",sum);&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>二进制枚举</tag>
        <tag>pair</tag>
        <tag>Atcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序模板]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;vector&lt;int&gt; G[maxn];int in[maxn],seq[maxn];int n,m,cnt = 0;void topology()&#123; for(int i = 1;i &lt;= n;i++)&#123; if(in[i] == 0) seq[++cnt] = i; &#125; int head = 1; while(head &lt;= cnt)&#123; int u = seq[head]; int ans = cnt; for(int i = 0;i &lt; G[u].size();i++)&#123; int v = G[u][i]; in[v]--; if(in[v] == 0) seq[++cnt] = v; &#125; head++; &#125; //当cnt不等于n时，说明这图有环&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i = 1;i &lt;= m;i++)&#123; int x,y; scanf("%d %d",&amp;x,&amp;y); G[x].push_back(y); in[y]++;; &#125; topology(); for(int i = 1;i &lt;= cnt;i++) printf("%d\n",seq[i]);&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去重全排列]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%8E%BB%E9%87%8D%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[公式为:$ \frac{n!}{(k_1)! (k_2)! … (k_p)!} $ $n$ : 串长度 $k_i$ : 串中第 $i$ 种元素出现的次数 $p$ : 串中不同元素的个数 例如：串为 $abac$ , 求串的去重全排列的个数 串的长度为 $4$ , 所以 $n$ $=$ $4$ 在这个串中，一共有 $3$ 种元素，分别为 $a$ , $b$ , $c$ 所以 $p$ $=$ $3$. 元素 $a$ 出现 $2$ 次,所以 $k_1$ $=$ $2$ 元素 $b$ 出现 $1$ 次,所以 $k_2$ $=$ $1$ 元素 $c$ 出现 $1$ 次,所以 $k_3$ $=$ $1$ 所以去重全排列个数为：$\frac{4!}{(2)! (1)! (1)! }$ $=$ $12$ 去重全排列如下：1.aabc 2.aacb 3.abac 4.abca 5.acab 6.acba 7.cbaa 8.bcaa 9.caba 10.acba 11.baca 12.abca]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dfs序模板]]></title>
    <url>%2F2018%2F07%2F08%2Fdfs%E5%BA%8F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;vector&lt;int&gt;G[maxn];int in[maxn],out[maxn],d[maxn];int tot = 0;void dfs(int x,int pre,int deep)&#123; in[x] = ++tot; d[x] = deep; for(int i = 0;i &lt; G[x].size();i++)&#123; int v = G[x][i]; if(v != pre) dfs(v,x,deep + 1); &#125; out[x] = tot;&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= m;i++)&#123; int x,y; cin &gt;&gt; x &gt;&gt; y; G[x].push_back(y); G[y].push_back(x); &#125; dfs(1,0,0); for(int i = 1;i &lt;= n;i++)&#123; printf("%d %d %d\n",i,in[i],out[i]);//节点i的子树的编号 &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流(最大流)模板题]]></title>
    <url>%2F2018%2F07%2F08%2F%E7%BD%91%E7%BB%9C%E6%B5%81(%E6%9C%80%E5%A4%A7%E6%B5%81)%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意:现在有m个池塘(从1到m开始编号,1为源点,m为汇点),及n条有向水渠,给出这n条水渠所连接的点和所能流过的最大流量，求从源点到汇点能流过的最大流量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110InputThe input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. OutputFor each case, output a single integer, the maximum rate at which water may emptied from the pond. Sample Input5 41 2 401 4 202 4 202 3 303 4 10 Sample Output50 SourceUSACO 93 Recommendlwg#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;int pre[2 * maxn],last[maxn],other[2 * maxn],deep[maxn];LL cost[maxn];int all = -1,n,m;int aim;void build(int x,int y,LL z)&#123; pre[++all] = last[x]; last[x] = all; other[all] = y; cost[all] = z;&#125;bool Bfs(int S,int T)&#123; memset(deep,0,sizeof(deep)); deep[S] = 1; queue&lt;int&gt; seq; seq.push(S); while(!seq.empty())&#123; int x = seq.front(); seq.pop(); int dt = last[x]; while(dt != -1)&#123; int dr = other[dt]; if(!deep[dr] &amp;&amp; cost[dt])&#123; deep[dr] = deep[x] + 1; seq.push(dr); &#125; dt = pre[dt]; &#125; &#125; return deep[T];&#125;LL dfs(int now,LL fl)&#123; if(now == aim) return fl; LL f = 0; int dt = last[now]; while(dt != -1)&#123; int dr = other[dt]; if(cost[dt] &amp;&amp; deep[dr] == deep[now] + 1)&#123; LL x = dfs(dr,min(fl,cost[dt])); cost[dt] -= x; cost[dt ^ 1] += x; fl -= x; f += x; &#125; dt = pre[dt]; &#125; if(!f) deep[now] = -2; return f;&#125;LL Dinic(int S,int T)&#123; aim = T;LL sum = 0; while(Bfs(S,T))&#123; sum += dfs(S,1LL &lt;&lt; 60); &#125; return sum;&#125;int main()&#123; while(~scanf("%d %d",&amp;m,&amp;n))&#123; memset(last,-1,sizeof(last)); all = -1; for(int i = 1;i &lt;= m;i++)&#123; int x,y; LL z; scanf("%d %d %lld",&amp;x,&amp;y,&amp;z); build(x,y,z); build(y,x,0); &#125; printf("%lld\n",Dinic(1,n)); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组总结]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一. 最长公共前缀给定一个字符串，询问某两个后缀的最长公共前缀。 算法分析：按照上面所说的做法，求两个后缀的最长公共前缀可以转化为求某个区间上 的最小值。对于这个 RMQ 问题，可以用 O(nlogn)的时间先预处理，以后每次回答询问的时间为 O(1)。所以对于本问题，预处理时间为 O(nlogn)，每次回答询问的时间为 O(1)。如果 RMQ 问题用 O(n)的时间预处理，那么本问题预处理的时间可以做到 O(n)。 123456789101112131415161718192021void RMQ()&#123; for(int i = 0; i &lt;= len;i++) dp[i][0] = lcp[i]; for(int j = 1;j &lt;= 20;j++)&#123; for(int i = 0;i &lt;= len;i++)&#123; if(i + (1 &lt;&lt; j) - 1 &lt;= len)&#123; dp[i][j] = min(dp[i][j - 1],dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; &#125;&#125;int Get_RMQ(int L,int R)&#123; if(L &gt; R) L--,swap(L,R); else R--; int kk = (int) log2(1.0 * (R - L + 1)); return min(dp[L][kk],dp[R - (1 &lt;&lt; kk) + 1][kk]);&#125;int main()&#123; int com = Get(Rank[i],Rank[j]);//查询以s[i]和s[j]为开头的最长公共前缀&#125; 二.可重叠最长重复子串给定一个字符串，求最长重复子串，这两个子串可以重叠。算法分析：这道题是后缀数组的一个简单应用。做法比较简单，只需要求 height 数组里的最大值即可。首先求最长重复子串，等价于求两个后缀的最长公共前缀的最大值。因为任意两个后缀的最长公共前缀都是 height 数组里某一段的最小值，那么这个值一定不大于 height 数组里的最大值。所以最长重复子串的长度就是height 数组里的最大值。这个做法的时间复杂度为 O(n)。 三.不可重叠最长重复子串给定一个字符串，求最长重复子串，这两个子串不能重叠。算法分析：这题比上一题稍复杂一点。先二分答案，把题目变成判定性问题：判断是否存在两个长度为 k 的子串是相同的，且不重叠。解决这个问题的关键还是利用height 数组。把排序后的后缀分成若干组，其中每组的后缀之间的 height 值都不小于 k。例如，字符串为“aabaaaab”，当 k=2 时，后缀分成了 4 组，如图 5所示。 容易看出，有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然后对于每组后缀，只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于k。如果有一组满足，则说明存在，否则不存在。整个做法的时间复杂度为O(nlogn)。本题中利用 height 值对后缀进行分组的方法很常用。 1234567891011121314151617181920212223242526272829303132Sample Input8 21 2 3 2 3 2 3 1 Sample Output4bool check(int mid)&#123; int sum = 0; for (int i = n + 1; i &gt;= 0; i--)&#123; if(lcp[i] &lt; mid) sum = 0; else&#123; sum++; if(sum + 1 &gt;= m) return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++) scanf("%d",&amp;s[i]); Creat_sa(); Creat_lcp(); int l = 1,r = n,ans = 1; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans);&#125; 四.可重叠的 k 次最长重复子串给定一个字符串，求至少出现 k 次的最长重复子串，这 k 个子串可以重叠。算法分析：这题的做法和上一题差不多，也是先二分答案，然后将后缀分成若干组。不同的是，这里要判断的是有没有一个组的后缀个数不小于 k。如果有，那么存k 个相同的子串满足条件，否则不存在。这个做法的时间复杂度为 O(nlogn)。 五.不相同的子串的个数1234567891011121314int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; Init(); scanf("%s",s); len = strlen(s); Creat_sa(); Creat_lcp(); LL n = len; for(int i = 0;i &lt;= len;i++) sum += lcp[i]; printf("%lld\n",n * (n + 1LL) / 2LL - sum); &#125; return 0;&#125; 六.重复次数最多的连续重复子串给定一个字符串，求重复次数最多的连续重复子串。算法分析：先穷举长度 L，然后求长度为 L 的子串最多能连续出现几次。首先连续出现1 次是肯定可以的，所以这里只考虑至少 2 次的情况。假设在原字符串中连续出现 2次，记这个子字符串为 S，那么 S 肯定包括了字符 r[0], r[L], r[L2],r[L3], ……中的某相邻的两个。所以只须看字符 r[Li]和 r[L(i+1)]往前和往后各能匹配到多远，记这个总长度为 K，那么这里连续出现了 K/L+1 次。最后看最大值是多少。 穷举长度 L 的时间是 n，每次计算的时间是 n/L。所以整个做法的时间复杂度是 O(n/1+n/2+n/3+……+n/n)=O(nlogn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Sample Inputccabababcdaabbccaa#Sample OutputCase 1: abababCase 2: aavoid Solve()&#123; ma = 1;//, ma_len = len; for(int l = 1;l &lt;= len;l++)&#123; int pos1 = 0,pos2 = l,cnt = 0,p1,p2; while(pos2 &lt; len)&#123; cnt = Get_RMQ(Rank[pos1],Rank[pos2]); p1 = pos1 - (l - cnt % l); p2 = pos2 - (l - cnt % l); if(p1 &gt;= 0 &amp;&amp; p2 &gt;= 0)&#123; int sum = Get_RMQ(Rank[p1],Rank[p2]); cnt += sum &gt;= l ? (l - cnt % l) : 0; &#125; if(ma == cnt / l + 1) ans.push_back(l); else if(ma &lt; cnt / l + 1)&#123; ans.clear(); ans.push_back(l); ma = cnt / l + 1; &#125; pos1 = pos2,pos2 = pos1 + l; &#125; &#125;&#125;int main()&#123; int t = 0; while(~scanf("%s",s))&#123; if(s[0] == '#') break; memset(dp,0,sizeof(dp)); memset(lcp,0,sizeof(lcp)); memset(Rank,0,sizeof(Rank)); len = strlen(s); Creat_sa(); Creat_lcp(); RMQ(); Solve(); printf("Case %d: ",++t); bool flag = 0; pos = 0,ma_len = 1; //printf("%d\n",ma); //for(int i = 0;i &lt; ans.size();i++) printf("%d\n",ans[i]); for(int i = 1;i &lt;= len;i++)&#123; for(int j = 0;j &lt; ans.size();j++)&#123; if(sa[i] + ans[j] &gt;= len) break; //printf("*%d %d\n",sa[i],ans[j]); if(Get_RMQ(Rank[sa[i]],Rank[sa[i] + ans[j]]) &gt;= (ma - 1) * ans[j])&#123; pos = sa[i]; ma_len = ans[j] * ma; flag = 1; break; &#125; &#125; if(flag) break; &#125; for(int i = 0;i &lt; ma_len;i++)&#123; printf("%c",s[pos + i]); &#125; printf("\n"); &#125;&#125; 七.子串的个数长度不小于 k 的公共子串的个数 给定两个字符串 A 和 B，求长度不小于 k 的公共子串的个数（可以相同）。 样例 1:A=“xx”，B=“xx”，k=1，长度不小于 k 的公共子串的个数是 5。 样例 2:A =“aababaa”，B =“abaabaa”，k=2，长度不小于 k 的公共子串的个数是22。 算法分析: 基本思路是计算 A 的所有后缀和 B 的所有后缀之间的最长公共前缀的长度，把最长公共前缀长度不小于 k 的部分全部加起来。先将两个字符串连起来，中间用一个没有出现过的字符隔开。按 height 值分组后，接下来的工作便是快速的统计每组中后缀之间的最长公共前缀之和。扫描一遍，每遇到一个 B 的后缀就统计与前面的 A 的后缀能产生多少个长度不小于 k 的公共子串，这里 A 的后缀需要用一个单调的栈来高效的维护。然后对 A 也这样做一次。 八.不小于 k 个字符串中的最长子串给定 n 个字符串，求出现在不小于 k 个字符串中的最长子串。 算法分析: 将 n 个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，用和例 3 同样的方法将后缀分成若干组，判断每组的后缀是否出现在不小于 k 个的原串中。这个做法的时间复杂度为O(nlogn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102K = n / 2 Sample Input3abcdefgbcdefghcdefghi3xxxyyyzzz0Sample Outputbcdefgcdefgh?bool check(int mid)&#123; int sum = 0; memset(vis,0,sizeof(vis)); for(int i = 0;i &lt;= len;i++)&#123; if(lcp[i] &lt; mid)&#123; memset(vis,0,sizeof(vis)); sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++; if(sum &gt; n / 2)&#123; return 1; &#125; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; if(n == 0) break; s.clear(); int all = 0; memset(tmp,0,sizeof(tmp)); memset(num,0,sizeof(num)); if(n == 1)&#123; cin &gt;&gt; s; cout &lt;&lt; s &lt;&lt; endl &lt;&lt; endl; continue; &#125; int cnt = 200; for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; h; for(int j = 0;j &lt; h.size();j++)&#123; num[all++] = i; s += h[j]; &#125; s += ('A' + (++cnt)),num[all++] = 0; &#125; len = s.size(); Creat_sa(); Creat_lcp(); int l = 1,r = len,ans = -1; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; if(ans == -1) printf("?\n\n"); else&#123; int sum = 0; vector&lt;int&gt; cnt; int pos = -1; memset(vis,0,sizeof(vis)); for(int i = 1;i &lt; len;i++)&#123; if(lcp[i] &lt; ans) &#123; memset(vis,0,sizeof(vis)),sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(x != y)&#123; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++,pos = sa[i]; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++,pos = sa[i + 1]; &#125; if(sum &gt; n / 2 &amp;&amp; lcp[i + 1] &lt; ans) cnt.push_back(pos); &#125; &#125; for(int i = 0;i &lt; cnt.size();i++)&#123; for(int j = cnt[i];j &lt;= cnt[i] + ans - 1;j++)&#123; cout &lt;&lt; s[j]; &#125; cout &lt;&lt; endl; &#125; printf("\n"); &#125; &#125;&#125; 九.每个字符串至少出现两次且不重叠的最长子串给定 n 个字符串，求在每个字符串中至少出现两次且不重叠的最长子串。 算法分析: 做法和上题大同小异，也是先将 n 个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串中至少出现两次，并且在每个原来的字符串中，后缀的起始位置的最大值与最小值之差是否不小于当前答案（判断能否做到不重叠，如果题目中没有不重叠的要求，那么不用做此判断）。这个做法的时间复杂度为 O(nlogn)。 十.出现或反转后出现在每个字符串中的最长子串给定 n 个字符串，求出现或反转后出现在每个字符串中的最长子串。 算法分析: 这题不同的地方在于要判断是否在反转后的字符串中出现。其实这并没有加大题目的难度。只需要先将每个字符串都反过来写一遍，中间用一个互不相同的且没有出现在字符串中的字符隔开，再将 n 个字符串全部连起来，中间也是用一个互不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串或反转后的字符串中出现。这个做法的时间复杂度为 O(nlogn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Sample Input23ABCDBCDFFBRCD2roseorchidSample Output22 bool check(int mid)&#123; int sum = 0; memset(vis,0,sizeof(vis)); for(int i = 0;i &lt;= len + 1;i++)&#123; if(lcp[i] &lt; mid)&#123; memset(vis,0,sizeof(vis)); sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++; if(sum == n) return 1; &#125; &#125; return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); s.clear(); int all = 0; int cnt = 200; memset(tmp,0,sizeof(tmp)); memset(num,0,sizeof(num)); for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; h; for(int j = 0;j &lt; h.size();j++)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt)); num[all++] = 0; for(int j = h.size() - 1;j &gt;= 0;j--)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt)); num[all++] = 0; &#125; len = s.size(); Creat_sa(); Creat_lcp(); int l = 1,r = 105,ans = 0; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组-求最长公共子串长度]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题意: 求最长公共子串长度（反转也算） Sample Input:1234567823ABCDBCDFFBRCD2roseorchid Sample Output:1222 解题思路:把原串和反转后的串连在一起，然后二分长度，分组Check。 AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 2e4 + 5;int sa[maxn],Rank[maxn],lcp[maxn],tmp[maxn];string s,h;int len,k,n;int num[maxn];bool vis[105];bool cmp(int i,int j)&#123; if(Rank[i] != Rank[j]) return Rank[i] &lt; Rank[j]; else&#123; int ri = i + k &lt;= len ? Rank[i + k] : -1; int rj = j + k &lt;= len ? Rank[j + k] : -1; return ri &lt; rj; &#125;&#125;void Creat_sa()&#123; for(int i = 0;i &lt;= len;i++)&#123; sa[i] = i; Rank[i] = i &lt; len ? s[i] : -1; &#125; for(k = 1;k &lt;= len;k *= 2)&#123; sort(sa,sa + len + 1,cmp); tmp[sa[0]] = 0; for(int i = 1;i &lt;= len;i++)&#123; tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1],sa[i]) ? 1 : 0); &#125; for(int i = 0;i &lt;= len;i++) Rank[i] = tmp[i]; &#125;&#125;void Creat_lcp()&#123; for(int i = 0;i &lt;= len;i++) Rank[sa[i]] = i; int h = 0; lcp[0] = 0; for(int i = 0;i &lt;= len;i++)&#123; int j = sa[Rank[i] - 1]; if(h &gt; 0) h--; for(;i + h &lt; len &amp;&amp; j + h &lt; len;h++)&#123; if(s[i + h] != s[j + h]) break; &#125; lcp[Rank[i] - 1] = h; &#125;&#125;bool check(int mid)&#123; int sum = 0; memset(vis,0,sizeof(vis)); for(int i = 0;i &lt;= len + 1;i++)&#123; if(lcp[i] &lt; mid)&#123; memset(vis,0,sizeof(vis)); sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++; if(sum == n) return 1; &#125; &#125; return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); s.clear(); int all = 0; int cnt = 200; memset(tmp,0,sizeof(tmp)); memset(num,0,sizeof(num)); for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; h; for(int j = 0;j &lt; h.size();j++)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt));//用从未出现过的字符相连 num[all++] = 0; for(int j = h.size() - 1;j &gt;= 0;j--)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt)); num[all++] = 0; &#125; len = s.size(); Creat_sa(); Creat_lcp(); int l = 1,r = 105,ans = 0; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZOJ - 3769 - Diablo III (分组背包 ，dp)]]></title>
    <url>%2F2018%2F07%2F08%2FZOJ%20-%203769%20-%20Diablo%20III%20(%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%20%EF%BC%8Cdp)%2F</url>
    <content type="text"><![CDATA[题意： 多组输入 每组先输入 n ， m。 n ： 总共有 n 件装备。 m ： 挑选的装备耐久度之和要大于等于 m。 接下来的 n 行，第 i 行，输入第 i 件装备的种类 Si ，伤害值 Di ，耐久度 Ti。 条件1：如果装备了 Two-Handed ， 就不能装备 Weapon ， Shield 其中任一一种装备。 条件2：可以选择装备一个 Finger ，也可以选择装备两个 Finger，其他相同种类的装备只能装备一个。 问:在满足所挑选的装备的耐久度之和大于等于 m 条件下，使得所挑选装备的总伤害值最大。若存在，输出总伤害值，否则，输出 -1。 Sample Input:12345678910111213141516171821 25Hand 30 205 25Weapon 15 5Shield 5 15Two-Handed 25 5Finger 5 10Finger 5 10 Sample Output:123-135 数据范围：$N (1 &lt;= N &lt;= 300)$ ,$M (0 &lt;= M &lt;= 50000)$ ,$(1 &lt;= Di, Ti &lt;= 50000).$ 解题思路： 若不考虑 条件1 和 条件2 的话，这道题就相当于是 分组背包 。 考虑 条件1 ：既然装备了 Two-Handed ， 就不能装备 Weapon ， Shield 其中任一一种装备的话，那我们就可以把【单个 Two-Handed】，【单个 Weapon】，【单个 Shield】和【Weapon 和 Shield 两两组合】当做同一种种类的装备，这样就不会冲突了。 考虑 条件2 ：我们可以把【单个 Finger 】和【Finger 和 Finger 两两组合】（要排除自己和自己组合）当做同一种种类的装备。 状态： $dp[i][j]$ : 后 i 种物品，耐久度达到 j 时 ，所能得到的最大伤害值。(因为题目数据的原因，所以要倒着来） 转移方程：不选第 i 种装备：$dp[i][j] = max(dp[i][j],dp[i + 1][j]);$ 选第 i 种装备：$dp[i][lim] = max(dp[i][lim],dp[i + 1][j] + cnt.d); $ $(lim = min(m,lim + cnt.t))$ 第二维不一定要写 j , 这样就不用考虑耐久度超过 m 了。 最后答案: $ dp[1][m]$。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;map&lt;string,int&gt; f;int dp[15][50005];//dp[i][j] : 后 i 种物品，耐久度达到 j 时 ，所能得到的最大伤害值。struct X&#123; int d,t;&#125;;vector&lt;X&gt; p[20];void Init()&#123; f["Head"] = 1 , f["Shoulder"] = 2 , f["Neck"] = 3; f["Torso"] = 4 , f["Hand"] = 5 , f["Wrist"] = 6; f["Waist"] = 7 , f["Legs"] = 8 , f["Feet"] = 9; f["Finger"] = 12 , f["Shield"] = 13 , f["Weapon"] = 14; f["Two-Handed"] = 15;&#125;void slove1()&#123;//处理 Finger。合并为编号 10 种类的装备。 for(int i = 0;i &lt; p[12].size();i++)&#123; p[10].push_back(p[12][i]); for(int j = i + 1;j &lt; p[12].size();j++)&#123; X cnt1,cnt2; cnt1 = p[12][i]; cnt2 = p[12][j]; cnt1.d += cnt2.d; cnt1.t += cnt2.t; p[10].push_back(cnt1); &#125; &#125;&#125;void slove2()&#123;//处理 Shield , Weapon , Two-Handed。合并为编号 11 种类的装备。 X cnt1,cnt2; for(int i = 0;i &lt; p[14].size();i++) p[11].push_back(p[14][i]); for(int i = 0;i &lt; p[13].size();i++)&#123; p[11].push_back(p[13][i]); for(int j = 0;j &lt; p[14].size();j++)&#123; cnt1 = p[13][i]; cnt2 = p[14][j]; cnt1.d += cnt2.d; cnt1.t += cnt2.t; p[11].push_back(cnt1); &#125; &#125; for(int i = 0;i &lt; p[15].size();i++)&#123; p[11].push_back(p[15][i]); &#125;&#125;int main()&#123; int t; Init(); while(cin &gt;&gt; t)&#123; while(t--)&#123; for(int i = 1;i &lt;= 20;i++) p[i].clear(); memset(dp,-1,sizeof(dp)); int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1;i &lt;= n;i++)&#123; X cnt; int x,d,t; string s; cin &gt;&gt; s &gt;&gt; d &gt;&gt; t; x = f[s]; cnt.d = d,cnt.t = t; p[x].push_back(cnt); &#125; slove1(); slove2(); dp[12][0] = 0; for(int i = 11;i &gt;= 1;i--)&#123; for(int j = 0;j &lt;= m;j++)&#123; dp[i][j] = max(dp[i][j],dp[i + 1][j]); if(dp[i + 1][j] == -1) continue;//这里表示 dp[i + 1][j] 状态不存在（在这道题等价于初始化为负无穷）。 for(int k = 0;k &lt; p[i].size();k++)&#123;// dp 的含义是当前状态的最优解，不管当前状态之前怎么选。 int lim; X cnt; cnt = p[i][k]; if(j + cnt.t &gt; m) lim = m;//第二维不一定要写 j , 这样就不用考虑耐久度超过 m 了。 else lim = j + cnt.t; dp[i][lim] = max(dp[i][lim],dp[i + 1][j] + cnt.d); &#125; &#125; &#125; cout &lt;&lt; dp[1][m] &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>分组背包</tag>
        <tag>ZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2955-Robberies(01背包，逆向思维)]]></title>
    <url>%2F2018%2F07%2F08%2FHDU-2955-Robberies(01%E8%83%8C%E5%8C%85%EF%BC%8C%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4)%2F</url>
    <content type="text"><![CDATA[题意： 输入一个 t ，表示有 t 组数据。 每组数据先输入 一个 P 和 一个 n。 P 代表被抓的概率需要低于 P，n 代表有 n 个银行。 接下来 n 行的每行输入一个 w 和 p。 w 代表当前银行所有的金额，p 代码当前银行被抓的概率。 问：小偷在被抓的概率低于 P 的情况下，最多能偷多少钱？ Sample Input:1234567891011121314151630.04 31 0.022 0.033 0.050.06 32 0.032 0.033 0.050.10 31 0.032 0.023 0.05 Sample Output:123246 数据范围：$ 0 &lt; T &lt;= 100$$0.0 &lt;= P &lt;= 1.0$$0 &lt; N &lt;= 100$$0 &lt; Mj &lt;= 100$$0.0 &lt;= Pj &lt;= 1.0$ 解题思路： 被抓概率 = 1 - 不被抓概率，所以只要 不被抓概率 &gt;= 1 - P。 01背包。 dp[i] : 偷到 i 金额的钱，而不被抓的最大概率。 dp[0] 初始化为 1.0 , 因为不偷任何东西时，不被转最大概率为 1.0。 转移方程：${dp[j] = dp[j - w[i]] * (1.0 - p[i]);}$ 最后答案就在满足不被抓概率 &gt;= 1 - P 中，取最大金额。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;double dp[10005],p[105];int w[105];int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; double P; int n; scanf("%lf %d",&amp;P,&amp;n); P = 1.0 - P; for(int i = 1;i &lt;= n;i++) scanf("%d %lf",&amp;w[i],&amp;p[i]); memset(dp,0,sizeof(dp)); dp[0] = 1.0; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 10000;j &gt;= w[i];j--)&#123; if(dp[j] &lt; dp[j - w[i]] * (1.0 - p[i]))&#123; dp[j] = dp[j - w[i]] * (1.0 - p[i]); &#125; &#125; &#125; int sum = 0; for(int i = 0;i &lt;= 10000;i++)&#123; if(dp[i] &gt;= P) sum = max(sum,i); &#125; printf("%d\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>01背包</tag>
        <tag>逆向思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2844 - Coins (多重背包,dp）]]></title>
    <url>%2F2018%2F07%2F08%2FHDU%20-%202844%20-%20Coins%20(%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%2Cdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： 多组输入。每组数据先输入一个 n , m 。 n : 有 n 种硬币； m : 所选硬币总和不超过 m ; 接下来输入 A1 , A2 , A3…An。代表第 i 种硬币的面值。 接着再输入 C1 , C2 , C3…Cn。代表第 i 种硬币的数量。 n == 0 &amp;&amp; m == 0 时结束。 问：在1 ~ m 种，有多少面值恰好能由所给的硬币组成？ Sample Input:12345673 101 2 4 2 1 12 51 4 2 10 0 Sample Output:1284 数据范围： $n(1 ≤ n ≤ 100)$ ,$m(m ≤ 100000)$,$(1 ≤ Ai ≤ 100000,1 ≤ Ci ≤ 1000)$ 参考博客：http://blog.csdn.net/u012762625/article/details/43485973http://blog.csdn.net/tinyguyyy/article/details/51203935 AC代码:解题代码①：1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;bool dp[100005];//dp[j] : 前 i 种物品是否能组成 j 。int a[105],c[105],cnt[100005];//cnt[j] : 当组成 j 时，这时第 i 种物品已经用的个数。int main()&#123; int n,m,sum; while(~scanf("%d %d",&amp;n,&amp;m))&#123; memset(dp,0,sizeof(dp)); if(n == 0 &amp;&amp; m == 0) break; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;c[i]); dp[0] = 1,sum = 0; for(int i = 1;i &lt;= n;i++)&#123; memset(cnt,0,sizeof(cnt)); for(int j = a[i];j &lt;= m;j++)&#123; if(!dp[j] &amp;&amp; cnt[j - a[i]] &lt; c[i] &amp;&amp; dp[j - a[i]])&#123; dp[j] = 1; sum++; cnt[j] = cnt[j - a[i]] + 1; &#125; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; 解题代码②:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;bool dp[100005];//dp[j]: 前 i 种物品是否能组成 j 。int a[105],c[105];int n,m,sum;void ZeroOnePack(int cost)&#123; for(int i = m;i &gt;= cost;i--)&#123; dp[i] = max(dp[i],dp[i - cost]); &#125;&#125;void CompletePack(int cost)&#123; for(int i = cost;i &lt;= m;i++)&#123; dp[i] = max(dp[i],dp[i - cost]); &#125;&#125;void MultiPack(int cost,int num)&#123; if(num * cost &gt; m)&#123; CompletePack(cost); &#125; else&#123; int k = 1;//二进制思想 while(k &lt; num)&#123; ZeroOnePack(cost * k); num -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(cost * num); &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;n,&amp;m))&#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;c[i]); memset(dp,0,sizeof(dp)); dp[0] = 1,sum = 0; for(int i = 1;i &lt;= n;i++)&#123; MultiPack(a[i],c[i]); &#125; for(int i = 1;i &lt;= m;i++)&#123; if(dp[i]) sum++; &#125; printf("%d\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>多重背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2159 - FATE(完全背包）]]></title>
    <url>%2F2018%2F07%2F08%2FHDU%20-%202159%20-%20FATE(%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： 多组数据。每组数据先输入 n，m，k，s。 n : 升级所需要的经验。 m : 所拥有的耐力。 k : 怪的种类。 s : 最多能杀的怪的数量。 接下来有 k 行，每行输入 a , b。 a : 杀死第 i 个怪所能获得的经验。 b : 杀死第 i 个怪所要消耗的耐力。 问：在满足所杀的怪的数量不超过 s , 所消耗的耐力不超过 m 时，最多剩下多少耐力？ Sample Input:12345678910 10 1 101 110 10 1 91 19 10 2 101 12 2 Sample Output:1230-11 数据范围： $(0 &lt; n,m,k,s &lt; 100)$ ,$(0 &lt; a,b &lt; 20)$ 解题思路： 这道题可以转化为完全背包来做。m 等价于背包的容量。a 等价于物品的价值。b 等价于物品的体积。但是这道题有一点要注意的地方，就是题目要求所杀的怪的数量不能超过 s。 所以需要增加一个 cnt[j]。cnt[j] : 前 i 种怪中，花费耐力不超过 j ，并且在获得最多经验时，最少杀的怪的数量。其他就直接按完全背包来做。 dp[j] : 前 i 种怪中，花费耐力不超过 j 时，最多能获得的经验。 转移方程看代码。 最后的答案就是在满足条件下，选一个剩下最多的经验。 优先级：所获经验 &gt; 杀怪数量 AC代码如下：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int dp[105];// dp[j] : 前 i 种怪中，花费耐力不超过 j 时，最多能获得的经验。int cnt[105];// cnt[j] : 前 i 种怪中，花费耐力不超过 j ，并且在获得最多经验时，最少杀的怪的数量。int a[105],b[105];int main()&#123; int n,m,k,s; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s)&#123; for(int i = 1;i &lt;= k;i++)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; memset(dp,0,sizeof(dp)); memset(cnt,0,sizeof(cnt)); for(int i = 1;i &lt;= k;i++)&#123; for(int j = b[i];j &lt;= m;j++)&#123; if(dp[j] &lt; dp[j - b[i]] + a[i])&#123;//转移方程(优先经验) dp[j] = dp[j - b[i]] + a[i]; cnt[j] = cnt[j - b[i]] + 1; &#125; else if(dp[j] == dp[j - b[i]] + a[i])&#123;//转移方程 cnt[j] = min(cnt[j],cnt[j - b[i]] + 1); &#125; &#125; &#125; int ans = -1; for(int i = 0;i &lt;= m;i++)&#123; if(dp[i] &gt;= n &amp;&amp; cnt[i] &lt;= s) ans = max(m - i,ans); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>HDU</tag>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1864 - 最大报销额 (浮点数 ，一维dp)]]></title>
    <url>%2F2018%2F07%2F08%2FHDU%20-%201864%20-%20%E6%9C%80%E5%A4%A7%E6%8A%A5%E9%94%80%E9%A2%9D%20(%E6%B5%AE%E7%82%B9%E6%95%B0%20%EF%BC%8C%E4%B8%80%E7%BB%B4dp)%2F</url>
    <content type="text"><![CDATA[题意：​ 多组输入。每组先输入 $Q$ 和 $N$（$Q$：最多报销金额，$N$：支票张数。接下来的 $N$ 行，每一行先输入 $m$ （$m$：当前支票上的报销类型数），然后输入 $m$ 个类型及其需报销金额。问：在满足 ： ①每张支票上报销的类型需是 $A$ 或 $B$ 或 $C$。②每张支票 $A$ 类型 或 $B$ 类型 或 $C$ 类型 需报销的各自总金额都不能超过 6000。③每张金额的总需报销金额小于 1000。 的条件下，最多能报销的金额。 Sample Input:12345678910111213141516171819202122232425200.00 3 2 A:23.50 B:100.00 1 C:650.00 3 A:59.99 A:120.00 X:10.00 1200.00 2 2 B:600.00 A:400.00 1 C:200.50 1200.50 3 2 B:600.00 A:400.00 1 C:200.50 1 A:100.00 100.00 0 Sample Output:12345123.50 1000.00 1200.50 数据范围：$ N &lt;= 30$ 解题思路：​ 01背包。因为题目数据是浮点数，答案保留2位小数，所以先将所有数据 100 变为 int 型，以方便计算。*dp[i]:总报销金额不超过 i 下的所能报销的最大金额（初始化都为0）。转移方程参见代码 AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;//因为题目数据是浮点数，答案保留2位小数，所以先将所有数据 * 100 变为 int 型，以方便计算。int dp[3000001];//dp[i]:总报销金额不超过 i 下的所能报销的最大金额。int cost[35];//cost[i]:符合条件的支票所需要报销的金额int main()&#123; double d_sum; int n,m,i_sum; while(scanf("%lf %d",&amp;d_sum,&amp;n) &amp;&amp; n)&#123; int all = 0; i_sum = (int)(d_sum * 100); while(n--)&#123; int sum_A = 0,sum_B = 0,sum_C = 0,sum = 0; bool flag = true; scanf("%d",&amp;m); while(m--)&#123; char type; double d_x; scanf(" %c:%lf",&amp;type,&amp;d_x); if(type == 'A') sum_A += (int)(d_x * 100); else if(type == 'B') sum_B += (int)(d_x * 100); else if(type == 'C') sum_C += (int)(d_x * 100); else flag = false; sum += (int)(d_x * 100); &#125; if(sum &gt; 100000 || sum_A &gt; 60000 || sum_B &gt; 60000 || sum_C &gt; 60000) flag = false; if(flag) cost[++all] = sum; &#125; memset(dp,0,sizeof(dp));//多组清空 for(int i = 1;i &lt;= all;i++)&#123; for(int j = i_sum;j &gt;= cost[i];j--)&#123;//要倒着是因为防止cost[i]被选了多次。 if(dp[j - cost[i]] + cost[i] &gt; dp[j]) dp[j] = dp[j - cost[i]] + cost[i]; &#125; &#125; printf("%.2lf\n",(double) (dp[i_sum] / 100.0)); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
        <tag>一维DP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[F.islands (强联通分量 + 缩点）]]></title>
    <url>%2F2018%2F07%2F08%2FF.islands%20(%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F%20%20%2B%20%E7%BC%A9%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意：给你一个有向图，问最少要添加多少条有向边使图中任意两点可以相互到达。 数据范围：$ (N≤10000)$ ,$M (M≤100000)$ 样例输入：12345678910111224 31 22 33 44 41 21 43 23 4 样例输出：12312 解题思路：​ 强联通分量 + 缩点 后得到一个有向无环图 $DAG$ 。然后求这个 $DAG$ 每个点的入度 $f[]$ 和 出度 $d[]$ ,然后 $all$ ：$DAG$ 中出度为 $0$ 点的个数；$ans$ ： $DAG$ 中入度为 $0$ 点的个数。最后答案 = $max(all,ans)$。注意：当只有一个强联通分量时不用添加边。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;int vis[maxn],low[maxn],dfn[maxn],in[maxn],f[maxn],d[maxn];vector&lt;int&gt; G[maxn * 10];stack&lt;int&gt; st; int n,m,ind,cnt;void Init()&#123; ind = cnt = 0; for(int i = 0;i &lt;= n;i++) G[i].clear(); memset(vis,0,sizeof(vis)); memset(in,0,sizeof(in)); memset(low,0,sizeof(low)); memset(dfn,0,sizeof(dfn)); memset(f,0,sizeof(f)); memset(d,0,sizeof(d));&#125;void dfs(int x)&#123;//求联通分量 + 缩点。 low[x] = dfn[x] = ++ind; st.push(x),vis[x] = 1; for(int i = 0;i &lt; G[x].size();i++)&#123; int v = G[x][i]; if(!dfn[v])&#123; dfs(v); low[x] = min(low[x],low[v]); &#125; else if(vis[v])&#123; low[x] = min(low[x],dfn[v]); &#125; &#125; if(low[x] == dfn[x])&#123; cnt++; while(!st.empty())&#123; int tot = st.top(); st.pop(); vis[tot] = 0; in[tot] = cnt;//在同一连通分量缩成一点 cnt。(同时cnt的值也等于图中连通分量的个数) if(tot == x) break; &#125; &#125;&#125;void slove()&#123;//求缩点后，每个连通分量的 入度 f[] 和 出度 d[]。 for(int i = 1;i &lt;= n;i++)&#123; for(int j = 0;j &lt; G[i].size();j++)&#123; int v = G[i][j]; if(in[i] != in[v])&#123; d[in[i]]++; f[in[v]]++; &#125; &#125; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; Init(); int x,y; scanf("%d %d",&amp;n,&amp;m); for(int i = 1;i &lt;= m;i++)&#123; scanf("%d %d",&amp;x,&amp;y); G[x].push_back(y); &#125; for(int i = 1;i &lt;= n;i++)&#123; if(!dfn[i]) dfs(i); &#125; if(cnt == 1)&#123; printf("0\n"); continue; &#125; slove(); int all,ans; all = ans = 0; for(int i = 1;i &lt;= cnt;i++)&#123; if(d[i] == 0) all++; if(f[i] == 0) ans++; &#125; printf("%d\n",max(ans,all)); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>强联通分量</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2018%2F04%2F20%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2222题目大意：给你 $n$ 个模式串和一个文本串，问文本串中一共出现过多少个模式串？ 样例：$Sample Input$ 12345678910111225shehesayshrheryasherhs1aaaaaa $Sample Output$ 1231 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e6 + 5;int sind;struct Node&#123; int nxt[26]; int count; int fail; void Init()&#123; memset(nxt,-1,sizeof(nxt)); fail = 0; count = 0; &#125;&#125;s[maxn];void Ins(char *str)&#123; int len = strlen(str); int ind = 0,i,j; for(i = 0;i &lt; len;i++)&#123; j = str[i] - 'a'; if(s[ind].nxt[j] == -1)&#123; s[sind].Init(); s[ind].nxt[j] = sind++; &#125; ind = s[ind].nxt[j]; &#125; s[ind].count++;&#125;void Get_fail()&#123; queue&lt;int&gt;seq; int i,ind = 0,ind_f; for(i = 0;i &lt; 26;i++)&#123; if(s[0].nxt[i] != -1)&#123; seq.push(s[0].nxt[i]); &#125; &#125; while(!seq.empty())&#123; ind = seq.front(); seq.pop(); for(i = 0;i &lt; 26;i++)&#123; if(s[ind].nxt[i] != -1)&#123; seq.push(s[ind].nxt[i]); ind_f = s[ind].fail; while(ind_f &gt; 0 &amp;&amp; s[ind_f].nxt[i] == -1) ind_f = s[ind_f].fail; if(s[ind_f].nxt[i] != -1) ind_f = s[ind_f].nxt[i]; s[s[ind].nxt[i]].fail = ind_f; &#125; &#125; &#125;&#125;int Find(char *des)&#123; int i,j,p,sum = 0,ind = 0; int len = strlen(des); for(i = 0;i &lt; len;i++)&#123; j = des[i] - 'a'; while(ind &gt; 0 &amp;&amp; s[ind].nxt[j] == -1) ind = s[ind].fail; if(s[ind].nxt[j] != -1)&#123; //printf("%d\n",ind); p = s[ind].nxt[j]; //printf("%d\n",p); ind = p; while(p &gt; 0 &amp;&amp; s[p].count != -1)&#123; //printf("%d\n",s[p].count); sum += s[p].count; s[p].count = -1; p = s[p].fail; &#125; &#125; &#125; return sum;&#125;int main()&#123; char str[maxn],des[maxn]; int t; scanf("%d",&amp;t); while(t--)&#123; sind = 1; s[0].Init(); int n; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++)&#123; scanf("%s",str); Ins(str); &#125; scanf("%s",des); Get_fail(); //printf("%d\n",s[4].fail); //printf("%d\n",s[1].count); printf("%d\n",Find(des)); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[马拉车总结]]></title>
    <url>%2F2018%2F04%2F11%2F%E9%A9%AC%E6%8B%89%E8%BD%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一.算法过程分析由于回文分为偶回文（比如 $bccb$）和奇回文（比如 $bcacb$），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，在字符间插入一个字符（前提这个字符未出现在串里）。举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文 abba 和一个奇回文 opxpo，被转换为 #a#b#b#a# 和 #o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组 int p[]， p[i] 表示以 ma[i]为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ma[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 4 5 2 1 2 1 2 1 2 1 2 1 6 1 2 1 可以看出，p[i]-1 正好是原字符串中最长回文串的长度。 二.定义 R 为以 ma[id] 为中心的最长回文最右边界，也就是 R = id + p[id]。$j$ 与 $i$关于 $id$ 对称，根据回文的性质，p[i] 的值基于以下三种情况得出:​ (1). $j$ 的回文串有一部分在 $id$ 的之外，如下图： ​ 上图中，黑线为 $id$ 的回文，$i$ 与 $j$ 关于 $id$ 对称，红线为 $j$ 的回文。那么根据代码此时p[i] = R-i，即紫线。那么p[i] 还可以更大么？答案是不可能！见下图： 假设右边新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，$a$ 等于 $d$ ，也就是说 $id$ 的回文不仅仅是黑线，而是黑线 + 两条紫线，矛盾，所以假设不成立，故p[i] = R-i，不可以再增加一分。 （2）j 回文串全部在 $id$ 的内部，如下图： 此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图： 假设右边新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，$a$ 等于 $b $，也就是说 $j$ 的回文应该再加上 $a$ 和 $b$ ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）$j$ 回文串左端正好与 $id$ 的回文串左端重合，见下图： 此时p[i] = p[j] 或 p[i] = R - i ，并且p[i] 还可以继续增加，所以需要 12while (ma[i - p[i]] == ma[i + p[i]]) p[i]++; 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 110010;char s[maxn];char Ma[maxn * 2];int p[maxn * 2];void Manacher(char s[], int len) &#123; int l = 0; Ma[l++] = '$'; Ma[l++] = '#'; for(int i = 0; i &lt; len; i++) &#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; int pos = 0, R = 0; for(int i = 0; i &lt; l; i++) &#123; if(i &lt; R)p[i] = min(p[pos * 2 - i], R - i); else p[i] = 1; while(Ma[i + p[i]] == Ma[i - p[i]])p[i]++; if(i + p[i] &gt; R) R = i + p[i], pos = i; &#125;&#125;int main() &#123; while(scanf("%s", s) != EOF) &#123; int Max = 0; int len = strlen(s); Manacher(s, len); for(int i = 0; i &lt; 2 * len + 2; i++) &#123; Max = max(Max, p[i] - 1); &#125; printf("%d\n", Max); &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>马拉车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2018%2F04%2F11%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[从大到小：$priority_queue &lt;int,vector,less &gt; p;$ 从小到大：$priority_queue &lt;int,vector,greater &gt; q;$ 优先队列里放 $pair$ :$typede$ $pair&lt;LL, int&gt; PII;$$vector ans;$$priority_queue&lt;PII, vector, greater &gt;que;$ 这里是首先让第一元素从小到大排序，当第一元素相等时，再按第二元素从大到小排序。 优先队列自定义重载：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;struct X&#123; int a,b; X () &#123;&#125; X (int aa,int bb) &#123; a = aa,b = bb; &#125; friend bool operator &lt; (const X A, const X B)&#123; if(A.a == B.a) return A.b &gt; B.b; //这里是反过来的，小于就是大于，大于就是小于。 else return A.a &gt; B.a; &#125;&#125;;X ans[maxn];priority_queue &lt;X&gt; pq;int main()&#123; ans[1].a = 1; ans[1].b = 2; ans[2].a = 2; ans[2].b = 1; ans[3].a = 1; ans[3].b = 3; pq.push(ans[1]); pq.push(ans[3]); pq.push(ans[2]); while(!pq.empty())&#123; X k = pq.top(); pq.pop(); printf("%d %d\n",k.a,k.b); &#125;&#125;输出：1 21 32 1]]></content>
      <categories>
        <category>队列</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名规范]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Codeforces:例如： $CF-div2-465.cpp$ $CF-E-div2-40.cpp$ ​ Atcoder:例如： $AT-R-093.cpp$ $AT-B-093.cpp$ $AT-G-093.cpp$ POJ:例如： $POJ$ $-$ $4745.cpp$]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra模板]]></title>
    <url>%2F2018%2F03%2F24%2FDijkstra%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int inf = 1 &lt;&lt; 30;const LL INF = 1LL &lt;&lt; 60;const int MaxN = 2000;int n, T;int all;int pre[2 * MaxN + 5], last[MaxN + 5], other[2 * MaxN + 5];int cost[2 * MaxN + 5];int dis[MaxN + 5];struct Node &#123; int id, d; Node () &#123;&#125; Node (int a, int b) : id(a), d(b) &#123;&#125; bool friend operator &lt; (Node a, Node b) &#123; return a.d &gt; b.d; &#125;&#125;;void build(int x, int y, int w) &#123; pre[++all] = last[x]; last[x] = all; other[all] = y; cost[all] = w;&#125;void Dijkstra(int s) &#123; for(int i = 1; i &lt;= n; i++) dis[i] = inf; dis[s] = 0; priority_queue &lt;Node&gt; pq; pq.push(Node(s, 0)); while(!pq.empty()) &#123; Node now = pq.top(); pq.pop(); int ed = last[now.id]; while(ed != -1) &#123; int dr = other[ed]; if(dis[now.id] + cost[ed] &lt; dis[dr]) &#123; dis[dr] = dis[now.id] + cost[ed]; pq.push(Node(dr, dis[dr])); &#125; ed = pre[ed]; &#125; &#125;&#125;int main() &#123; while(scanf("%d %d", &amp;T, &amp;n) != EOF) &#123; all = -1; memset(last, -1, sizeof(last)); for(int i = 1; i &lt;= T; i++) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); build(u, v, w); build(v, u, w); &#125; Dijkstra(1); printf("%d\n", dis[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1141-Brackets Sequence]]></title>
    <url>%2F2018%2F03%2F23%2FPOJ-1141-Brackets-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接：http://poj.org/problem?id=1141 题目大意：​ 给你一个长度不超过 $100$ 且只包含 $( , ) , [ , ]$ 四种字符的字符串 $s$，添加 最少 的字符使其变成一个合法的字符串，输出这个合法的字符串。 合法字符串的定义： $Empty$ $sequence$ $is$ $a$ $regular$ $sequence. $ $If$ $S$ $is$ $a$ $regular$ $sequence$, $then$ $(S)$ $and$ $[S]$ $are$ $both$ $regular$ $sequences. $ $If$ $A$ $and$ $B$ $are$ $regular$ $sequences$, $then$ $AB$ $is$ $a$ $regular$ $sequence$. 样例：$Sample$ $ Input$ 1([(] $Sample$ $ Output$ 1()[()] 解题思路：这是一道 区间 $dp$ (路径还原) 状态方程 : $dp[i][j]$ 代表使 区间 $(i,j)$ 形成一个合法的字符串最少需要添加多的字符串？ ​ $path[i][j]$ 代表添加最少的字符使 区间 $(i,j)$ 形成一个合法的字符串的路径选择。 若 $path[i][j]$ $=$ $-1$ ,表示头尾。 若 $path[i][j]$ $=$ $k$ ($k$ != $-1$ ) ,表示由 区间 $(i,k)$ 和 区间 ($k + 1$ ,$j$) 而来。 转移方程： 区间 $(i,j)$ 可以由 区间 $(i,k)$ + 区间 $(k + 1,j)$ 转移而来。 当 $s[i]$ = $s[j]$ 时，区间 $(i,j)$ 也可以由 区间 $(i + 1,j - 1)$ 转移而来。（需要注意的是：当 $i + 1 = j$ 时，直接 $dp[i][j]$ = $0$，否则会出现 $i + 1 &gt; j - 1$ 的情况） 小思考：为什么最外层是枚举 区间长度，而不是直接枚举 区间端点 $l,r$ 呢？ 答：因为我们转移的时候是从 小区间 转移到 大区间 的。 最后答案：根据 $path[i][j]$ 记录的值，用递归还原路径。（详情请看代码） AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 105;int dp[maxn][maxn],path[maxn][maxn];char s[maxn];void dfs(int l,int r)&#123; if(l &gt; r) return; if(l == r)&#123; if(s[l] == '(' || s[l] == ')') cout &lt;&lt; "()"; else cout &lt;&lt; "[]"; return; &#125; if(path[l][r] == -1)&#123; cout &lt;&lt; s[l];//先输出左端点, dfs(l + 1,r - 1);//再输出中间, cout &lt;&lt; s[r];//最后输出右端点。 &#125; else&#123; int k = path[l][r];//分两部分输出。 dfs(l,k); dfs(k + 1,r); &#125;&#125;int main()&#123; int n; while(gets(s + 1))&#123; n = strlen(s + 1); memset(dp,0x3f,sizeof(dp)); memset(path,0,sizeof(path)); for(int i = 1;i &lt;= n;i++) dp[i][i] = 1;//初始化：自己当然初始化为 1,其他初始化为无穷大。 for(int len = 2;len &lt;= n;len++)&#123; for(int l = 1;l &lt;= n - len + 1;l++)&#123; int r = len + l - 1; if((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']'))&#123; if(dp[l + 1][r - 1] &lt; dp[l][r])&#123; dp[l][r] = dp[l + 1][r - 1]; path[l][r] = -1; &#125; else if(l + 1 == r)&#123; dp[l][r] = 0; path[l][r] = -1; &#125; &#125; for(int k = l;k &lt; r;k++)&#123; if(dp[l][k] + dp[k + 1][r] &lt; dp[l][r])&#123; dp[l][r] = dp[l][k] + dp[k + 1][r]; path[l][r] = k; &#125; &#125; &#125; &#125; dfs(1,n); cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-336-div2-D-Zuma]]></title>
    <url>%2F2018%2F03%2F20%2FCodeforces%20-%20336%20-%20div2%20-%20D.Zuma%2F</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/608/problem/D 题目大意：​ 给你一个长度为 $n$ 的序列 $c$，每次操作删去当前序列的一个回文串。问：把序列全部删完，最少需要多少次的操作? 数据范围：$1 \leq n \leq 10^5$ $1 \leq c_i \leq n$ 样例：$input$ 1231 2 1 $output$ 11 $In$ $the$ $first$ $sample$, $Genos$ $can$ $destroy$ $the$ $entire$ $line$ $in$ $one$ $second.$ $input$ 1231 2 3 $output$ 13 $In$ $the$ $second$ $sample$, $Genos$ $can$ $only$ $destroy$ $one$ $gemstone$ $at$ $a$ $time$, $so$ $destroying$ $three$ $gemstones $$takes$ $three$ $seconds.$ $input$ 1271 4 4 2 3 2 1 $output$ 12 $In$ $the$ $third$ $sample$, $to$ $achieve$ $the$ $optimal$ $time$ $of$ $two$ $seconds$, $destroy$ $palindrome$ $4$ $4$ $first$ $and$ $then$ $destroy$ $palindrome$ $1$ $2$ $3$ $2$ $1$. 解题思路：这是一道 区间 $dp$ 状态方程：$dp[i][j]$ 代表完全删除区间 $(i,j)$ 最少需要多少次操作？ 转移方程： 区间 $(i,j)$ 可以由 区间 $(i,k)$ + 区间 $(k + 1,j)$ 转移而来。 当 $c[i]$ = $c[j]$ 时，区间 $(i,j)$ 也可以由 区间 $(i + 1,j - 1)$ 转移而来。（需要注意的是：当 $i + 1 = j$ 时，直接 $dp[i][j]$ = 1，否则会出现 $i + 1 &gt; j - 1$ 的情况） 小思考1：为什么最外层是枚举 区间长度，而不是直接枚举 区间端点 $l,r$ 呢？ 答：因为我们转移的时候是从 小区间 转移到 大区间 的。 小思考2： 当 $c[i] = c[j]$ 时，为什么 区间 $(i,j)$ 是直接由 区间 $(i + 1,j - 1) $ 转移而来，而不是由 区间 $(i + 1, j - 1)$ $+ $ $1$ 转移而来？ 答：因为，若完全删除 区间 $(i + 1,j - 1)$ 最少需要 $k$ 次操作，那么我们可以在前 $k - 1$ 次操作删掉 区间 $(i + 1,j - 1)$ 的 $k - 1$ 部分，剩下的一部分可以与 $c[i],c[j]$ 形成一个回文串，最后再一起删掉,所以总操作次数还是 $k$ 次。 最后答案：$dp[1][n] $ 。 AC代码：12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1 &lt;&lt; 30;int c[505],dp[505][505];// dp[i][j] : 完全删除区间 (i,j) 最少需要多少次操作？int main()&#123; int n;cin &gt;&gt; n; memset(dp,0x3f,sizeof(dp));// 初始化为正无穷。 for(int i = 1;i &lt;= n;i++) cin &gt;&gt; c[i], dp[i][i] = 1;// 删除一个数时需要一次操作。 for(int len = 2;len &lt;= n;len++)&#123;// 枚举区间长度。 for(int l = 1;l &lt;= n - len + 1;l++)&#123;//枚举左端点。 int r = l + len - 1;//右端点。 for(int k = l;k &lt; r;k++)&#123; dp[l][r] = min(dp[l][r],dp[l][k] + dp[k + 1][r]); // 代表区间(l,r) 可以由 (l,k) + (k + 1,r) 转移。 &#125; if(c[l] == c[r])&#123;//当 a[l] = a[r]时。 if(l + 1 == r) dp[l][r] = 1;//若相邻,则需要一次操作。 dp[l][r] = min(dp[l][r],dp[l + 1][r - 1]);// (l,r) 当然可以由 (l + 1,r - 1) 转移。 &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法]]></title>
    <url>%2F2018%2F03%2F20%2FMarkdown-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&lt;span id=&quot;inline-blue&quot;&gt; 站点配置文件 &lt;/span&gt; 站点配置文件 &lt;span id=&quot;inline-purple&quot;&gt; 主题配置文件 &lt;/span&gt; 主题配置文件 &lt;span id=&quot;inline-yellow&quot;&gt; 站点配置文件 &lt;/span&gt; 站点配置文件 &lt;span id=&quot;inline-green&quot;&gt; 主题配置文件 &lt;/span&gt; ​ 主题配置文件 分数，平方 算式 markdown 7x+51+y27x+51+y2 \frac{7x+5}{1+y^2} 下标 算式 markdown z=zlz=zl z=z_l 省略号 省略号 markdown ⋯⋯ \cdots 行间公式（使用两个$包含公式可以独立一行） 行间公式 markdown ddxeax=aeax∑i=1n(Xi−X¯¯¯¯)2ddxeax=aeax∑i=1n(Xi−X¯)2 \frac{d}{dx}e^{ax}=ae^{ax}\quad \sum_{i=1}^{n}{(X_i - \overline{X})^2} 开根号 算式 markdown 2–√;3–√n2;3n \sqrt{2};\sqrt[n]{3} 矢量 算式 markdown a⃗ ⋅b⃗ =0a→⋅b→=0 \vec{a} \cdot \vec{b}=0 积分 算式 markdown ∫23x2dx∫32x2dx \int ^2_3 x^2 {\rm d}x 极限 算式 markdown limn→+∞nlimn→+∞n \lim_{n\rightarrow+\infty} n 累加 算式 markdown ∑1i2∑1i2 \sum \frac{1}{i^2} 累乘 算式 markdown ∏1i2∏1i2 \prod \frac{1}{i^2} 希腊字母 大写 markdown 小写 markdown AA A αα \alpha BB B ββ \beta ΓΓ \Gamma γγ \gamma ΔΔ \Delta δδ \delta EE E ϵϵ \epsilon εε \varepsilon ZZ Z ζζ \zeta HH H ηη \eta ΘΘ \Theta θθ \theta II I ιι \iota KK K κκ \kappa ΛΛ \Lambda λλ \lambda MM M μμ \mu NN N νν \nu ΞΞ \Xi ξξ \xi OO O οο \omicron ΠΠ \Pi ππ \pi PP P ρρ \rho ΣΣ \Sigma σσ \sigma 大写 markdown 小写 markdown TT T ττ \tau ΥΥ \Upsilon υυ \upsilon ΦΦ \Phi ϕϕ \phi φφ \varphi XX X χχ \chi ΨΨ \Psi ψψ \psi ΩΩ \Omega ωω \omega 三角函数 三角函数 markdown sinsin \sin 对数函数 算式 markdown ln15ln⁡15 \ln15 log210log2⁡10 \log_2 10 lg7lg⁡7 \lg7 关系运算符 运算符 markdown ±± \pm ×× \times ÷÷ \div ∑∑ \sum ∏∏ \prod ≠≠ \neq ≤≤ \leq ≥≥ \geq]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-C-Array Gcd]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-C-Array-Gcd%2F</url>
    <content type="text"><![CDATA[解题思路：​ 我们考虑到1操作也就是移除连续的一段区间的元素只能操作一次，而且长度是小于n的，那么最后得到的序列肯定是含有第一个元素或者是最后一个元素，那么根据这个性质我们就可以将 $a[1], a[1] +1, a[1] - 1, a[n], a[n] + 1, a[n] - 1$， 这6个数质数分解将质因子存在来，然后去枚举质因子， 对于每一个质因子序列里的每一个数成为这个质因子的代价是不同的，如果 $a[i]$ % $p$ = 0, $cost[i]$ = $0$、 ($a[i]$ +1) % $p$ = $0$ || ($a[i]$ - 1) % p = $0$, $cost[i]$ = $B$, 否则 $cost[i]$ = oo。那么这个时候我们就可以 $dp$ 了， $dp[i][0]$ 表示从一到 $i $ 这个位置还没有进行1操作的最小花费。$dp[i][1]$ 表示从一到 $i$ 这个位置正在进行1操作的最小花费。$dp[i][2]$ 表示从一到 $i$ 这个位置已经结束1操作了的最小花费。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;const int MaxN = 1e6;typedef long long LL;const LL Max = 1000000000000000000;using namespace std;LL n;LL a, b, c[MaxN + 5], dp[MaxN + 5][4];LL cost[MaxN + 5];vector &lt;LL&gt; G;void G_insert(LL x)&#123; for(LL i = 2;i * i &lt;= x;i++)&#123; if(x % i == 0)&#123; G.push_back(i); while(x % i == 0) x /= i; &#125; &#125; if(x != 1) G.push_back(x);&#125;void Init()&#123; G.clear(); for(int i = 1;i &lt;= n;i++) scanf("%I64d" , &amp;c[i]); for(LL i = -1;i &lt;= 1;i++) G_insert(c[1] + i); for(LL i = -1;i &lt;= 1;i++) G_insert(c[n] + i);&#125;LL Work(LL x)&#123; for(int i = 1;i &lt;= n;i++)&#123; cost[i] = dp[i][0] = dp[i][1] = dp[i][2] = 1LL &lt;&lt; 40; if(c[i] % x == 0) cost[i] = 0; else if((c[i] - 1) % x == 0 || (c[i] + 1) % x == 0) cost[i] = b; &#125; dp[0][0] = dp[0][1] = dp[0][2] = 0; for(int i = 1;i &lt;= n;i++)&#123; dp[i][0] = dp[i - 1][0] + cost[i]; dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a; dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + cost[i]; &#125; return min(dp[n][0] , min(dp[n][1], dp[n][2]));&#125;void Solve()&#123; LL ans = 1LL &lt;&lt; 60; for(int i = 0;i &lt; G.size();i++)&#123; ans = min(ans , Work(G[i])); &#125; printf("%I64d\n" , ans);&#125;int main()&#123; while(~scanf("%I64d%I64d%I64d" , &amp;n , &amp;a , &amp;b))&#123; Init(); Solve(); &#125;&#125;]]></content>
      <categories>
        <category>四校联赛</category>
      </categories>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-D-D商店]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-D-D%E5%95%86%E5%BA%97%2F</url>
    <content type="text"><![CDATA[题目大意：​ 先输入 $n，k$ 分别代表有 $n$ 天，可以让任意 $k$ 天的的物品数量翻倍(每天最多只能翻一次）。接下来有 $n$ 行，第 $i$ 行有两个数 $ai，bi$ 分别代表在第 $i$ 天有 $ai$ 件物品，有 $bi$ 个顾客。每个顾客都会买一件物品。问 n 天后最多卖出多少件物品? 数据范围：$1 \leq n \leq 10^5$ $0 \leq k \leq n$ $1 \leq a_i ,bi\leq 10^9$ 解题思路： 当天的存货量大于等于需求量的时候，这一天的存货量是不需要翻倍的。 当天存货量小于需求量的时候，先让这一天的存货量翻倍，求出当天 ”可增加“ 的销售量，然后根据可增加的销售量从大到小排序，选出前 $k$ 天。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;LL a[maxn],b[maxn],s[maxn];LL cmp(LL x,LL y)&#123; return x &gt; y;&#125;int main()&#123; int n,k; LL ans = 0,sum; scanf("%d %d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++)&#123; scanf("%I64d %I64d",&amp;a[i],&amp;b[i]); if(b[i] &gt; a[i])&#123; if(2 * a[i] &lt;= b[i]) s[i] = a[i]; else s[i] = b[i] - a[i]; &#125; else&#123; s[i] = 0; a[i] = b[i]; &#125; &#125; sort(s + 1,s + n + 1,cmp); for(int i = 1;i &lt;= k;i++) ans += s[i]; for(int i = 1;i &lt;= n;i++) ans += a[i]; printf("%I64d",ans);&#125;]]></content>
      <categories>
        <category>四校联赛</category>
      </categories>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces - 911 - D.Inversion Counting]]></title>
    <url>%2F2018%2F03%2F16%2FCodeforces%20-%20911%20-%20D.Inversion%20Counting%2F</url>
    <content type="text"><![CDATA[题目大意：给你 $n$ 个数，和 $m$ 个操作询问，每个询问给你 $l,r$ 两个数，问你反转 $l,r$ 区间的元素后，整个序列的逆序对的个数是奇数个还是偶数个，奇数个输出 $odd$ ,偶数个则输出 $even$ ,该逆序对以从小到大为标准次序，反转后不会恢复为原序列，且保证 $n$ 个数中每个数都不相同。 数据范围$1 \leq n \leq 1500,1 \leq m \leq 2 \cdot 10^5,1 \leq l_i \leq r_i \leq n,1 \leq a_i \leq n;​$ 解题思路：因为要求每次操作后逆序对的对数的奇偶性，如果想暴力做的话，每次对序列进行反转就是 $O(n)$ 的复杂度，还得重新求总逆序对个数，总复杂度就变为了 $O(n^{2}\cdot{m})$ ，这显然会 $TLE$ 的，所以得换个想法，我们先求出初始序列的总逆序对个数 $res$ ，根据 $[l,r]$ 区间逆序对的变化转换为总逆序对个数，但是真正的个数我们其实并不太需要，只需要知道奇偶性就行了；我们知道一个长度为len长的序列，它的逆序对最多为 $len\cdot(len-1)/2$ (假如该序列为从大到小排序，即总逆序对个数为 ($1+2+3+\dots+(len-1)=len\cdot(len-1)/2$) 暂且称为满逆序对,那么现逆序对个数即与满逆序对个数有关，若满逆序对个数为偶数个，那么现逆序对奇偶性与原逆序对相同，即为加减偶数个数，可以用 $len\cdot(len-1)/2$ 代替，否则当满逆序对个数为奇数个时，那么现逆序对奇偶性与原逆序对相反，即为加减奇数个，也可用 $len\cdot(len-1)/2$ 代替，所以每次只需要将 $res+=len\cdot(len-1)/2$ 后就可以直接判断奇偶性，$O(1)$ 出答案。 AC代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1500;int n, m, cnt;int a[maxn + 5];int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) if(a[i] &gt; a[j])cnt++; &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); cnt += (r - l + 1) * (r - l) / 2; if(cnt &amp; 1)printf("odd\n"); else printf("even\n"); &#125; return 0;&#125; 题目链接：Go to!]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2FHELLO%20WORLD%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
