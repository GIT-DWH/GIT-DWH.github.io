<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[马拉车]]></title>
    <url>%2F2018%2F04%2F11%2F%E9%A9%AC%E6%8B%89%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[一.算法过程分析由于回文分为偶回文（比如 $bccb$）和奇回文（比如 $bcacb$），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，在字符间插入一个字符（前提这个字符未出现在串里）。举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文 abba 和一个奇回文 opxpo，被转换为 #a#b#b#a# 和 #o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组 int p[]， p[i] 表示以 ma[i]为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ma[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 4 5 2 1 2 1 2 1 2 1 2 1 6 1 2 1 可以看出，p[i]-1 正好是原字符串中最长回文串的长度。 二.定义 R 为以 ma[id] 为中心的最长回文最右边界，也就是 R = id + p[id]。$j$ 与 $i$关于 $id$ 对称，根据回文的性质，p[i] 的值基于以下三种情况得出: (1). $j$ 的回文串有一部分在 $id$ 的**之外**，如下图： ​ 上图中，黑线为 $id$ 的回文，$i$ 与 $j$ 关于 $id$ 对称，红线为 $j$ 的回文。那么根据代码此时p[i] = R-i，即紫线。那么p[i] 还可以更大么？答案是不可能！见下图： 假设右边新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，$a$ 等于 $d$ ，也就是说 $id$ 的回文不仅仅是黑线，而是黑线 + 两条紫线，矛盾，所以假设不成立，故p[i] = R-i，不可以再增加一分。 （2）j 回文串全部在 $id$ 的内部，如下图： 此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图： 假设右边新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，$a$ 等于 $b $，也就是说 $j$ 的回文应该再加上 $a$ 和 $b$ ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）$j$ 回文串左端正好与 $id$ 的回文串左端重合，见下图： 此时p[i] = p[j] 或 p[i] = R - i ，并且p[i] 还可以继续增加，所以需要 12while (ma[i - p[i]] == ma[i + p[i]]) p[i]++; 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 110010;char s[maxn];char Ma[maxn * 2];int p[maxn * 2];void Manacher(char s[], int len) &#123; int l = 0; Ma[l++] = '$'; Ma[l++] = '#'; for(int i = 0; i &lt; len; i++) &#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; int pos = 0, R = 0; for(int i = 0; i &lt; l; i++) &#123; if(i &lt; R)p[i] = min(p[pos * 2 - i], R - i); else p[i] = 1; while(Ma[i + p[i]] == Ma[i - p[i]])p[i]++; if(i + p[i] &gt; R) R = i + p[i], pos = i; &#125;&#125;int main() &#123; while(scanf("%s", s) != EOF) &#123; int Max = 0; int len = strlen(s); Manacher(s, len); for(int i = 0; i &lt; 2 * len + 2; i++) &#123; Max = max(Max, p[i] - 1); &#125; printf("%d\n", Max); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2018%2F04%2F11%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[从大到小：$priority_queue]]></content>
  </entry>
  <entry>
    <title><![CDATA[命名规范]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Codeforces:例如： $CF-div2-465.cpp$ $CF-E-div2-40.cpp$ ​ Atcoder:例如： $AT-R-093.cpp$ $AT-B-093.cpp$ $AT-G-093.cpp$ POJ:例如： $POJ$ $-$ $4745.cpp$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2F2018%2F03%2F24%2FDijkstra%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int inf = 1 &lt;&lt; 30;const LL INF = 1LL &lt;&lt; 60;const int MaxN = 2000;int n, T;int all;int pre[2 * MaxN + 5], last[MaxN + 5], other[2 * MaxN + 5];int cost[2 * MaxN + 5];int dis[MaxN + 5];struct Node &#123; int id, d; Node () &#123;&#125; Node (int a, int b) : id(a), d(b) &#123;&#125; bool friend operator &lt; (Node a, Node b) &#123; return a.d &gt; b.d; &#125;&#125;;void build(int x, int y, int w) &#123; pre[++all] = last[x]; last[x] = all; other[all] = y; cost[all] = w;&#125;void Dijkstra(int s) &#123; for(int i = 1; i &lt;= n; i++) dis[i] = inf; dis[s] = 0; priority_queue &lt;Node&gt; pq; pq.push(Node(s, 0)); while(!pq.empty()) &#123; Node now = pq.top(); pq.pop(); int ed = last[now.id]; while(ed != -1) &#123; int dr = other[ed]; if(dis[now.id] + cost[ed] &lt; dis[dr]) &#123; dis[dr] = dis[now.id] + cost[ed]; pq.push(Node(dr, dis[dr])); &#125; ed = pre[ed]; &#125; &#125;&#125;int main() &#123; while(scanf("%d %d", &amp;T, &amp;n) != EOF) &#123; all = -1; memset(last, -1, sizeof(last)); for(int i = 1; i &lt;= T; i++) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); build(u, v, w); build(v, u, w); &#125; Dijkstra(1); printf("%d\n", dis[n]); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[POJ-1141-Brackets Sequence]]></title>
    <url>%2F2018%2F03%2F23%2FPOJ-1141-Brackets-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接：Go! 题目大意：​ 给你一个长度不超过 $100$ 且只包含 $( , ) , [ , ]$ 四种字符的字符串 $s$，添加 最少 的字符使其变成一个合法的字符串，输出这个合法的字符串。 合法字符串的定义： $Empty$ $sequence$ $is$ $a$ $regular$ $sequence. $ $If$ $S$ $is$ $a$ $regular$ $sequence$, $then$ $(S)$ $and$ $[S]$ $are$ $both$ $regular$ $sequences. $ $If$ $A$ $and$ $B$ $are$ $regular$ $sequences$, $then$ $AB$ $is$ $a$ $regular$ $sequence$. 样例：$Sample$ $ Input$ 1([(] $Sample$ $ Output$ 1()[()] 解题思路：这是一道 区间 $dp$ (路径还原) 状态方程 : $dp[i][j]$ 代表使 区间 $(i,j)$ 形成一个合法的字符串最少需要添加多的字符串？ ​ $path[i][j]$ 代表添加最少的字符使 区间 $(i,j)$ 形成一个合法的字符串的路径选择。 若 $path[i][j]$ $=$ $-1$ ,表示头尾。 若 $path[i][j]$ $=$ $k$ ($k$ != $-1$ ) ,表示由 区间 $(i,k)$ 和 区间 ($k + 1$ ,$j$) 而来。 转移方程： 区间 $(i,j)$ 可以由 区间 $(i,k)$ + 区间 $(k + 1,j)$ 转移而来。 当 $s[i]$ = $s[j]$ 时，区间 $(i,j)$ 也可以由 区间 $(i + 1,j - 1)$ 转移而来。（需要注意的是：当 $i + 1 = j$ 时，直接 $dp[i][j]$ = $0$，否则会出现 $i + 1 &gt; j - 1$ 的情况） 小思考：为什么最外层是枚举 区间长度，而不是直接枚举 区间端点 $l,r$ 呢？ 答：因为我们转移的时候是从 小区间 转移到 大区间 的。 最后答案：根据 $path[i][j]$ 记录的值，用递归还原路径。（详情请看代码） AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 105;int dp[maxn][maxn],path[maxn][maxn];char s[maxn];void dfs(int l,int r)&#123; if(l &gt; r) return; if(l == r)&#123; if(s[l] == '(' || s[l] == ')') cout &lt;&lt; "()"; else cout &lt;&lt; "[]"; return; &#125; if(path[l][r] == -1)&#123; cout &lt;&lt; s[l];//先输出左端点, dfs(l + 1,r - 1);//再输出中间, cout &lt;&lt; s[r];//最后输出右端点。 &#125; else&#123; int k = path[l][r];//分两部分输出。 dfs(l,k); dfs(k + 1,r); &#125;&#125;int main()&#123; int n; while(gets(s + 1))&#123; n = strlen(s + 1); memset(dp,0x3f,sizeof(dp)); memset(path,0,sizeof(path)); for(int i = 1;i &lt;= n;i++) dp[i][i] = 1;//初始化：自己当然初始化为 1,其他初始化为无穷大。 for(int len = 2;len &lt;= n;len++)&#123; for(int l = 1;l &lt;= n - len + 1;l++)&#123; int r = len + l - 1; if((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']'))&#123; if(dp[l + 1][r - 1] &lt; dp[l][r])&#123; dp[l][r] = dp[l + 1][r - 1]; path[l][r] = -1; &#125; else if(l + 1 == r)&#123; dp[l][r] = 0; path[l][r] = -1; &#125; &#125; for(int k = l;k &lt; r;k++)&#123; if(dp[l][k] + dp[k + 1][r] &lt; dp[l][r])&#123; dp[l][r] = dp[l][k] + dp[k + 1][r]; path[l][r] = k; &#125; &#125; &#125; &#125; dfs(1,n); cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-336-div2-D-Zuma]]></title>
    <url>%2F2018%2F03%2F20%2FCodeforces-336-div2-D-Zuma%2F</url>
    <content type="text"><![CDATA[题目链接：Go! 题目大意：​ 给你一个长度为 $n$ 的序列 $c$，每次操作删去当前序列的一个回文串。问：把序列全部删完，最少需要多少次的操作? 数据范围：$1 \leq n \leq 10^5$ $1 \leq c_i \leq n$ 样例：$input$ 1231 2 1 $output$ 11 $In$ $the$ $first$ $sample$, $Genos$ $can$ $destroy$ $the$ $entire$ $line$ $in$ $one$ $second.$ $input$ 1231 2 3 $output$ 13 $In$ $the$ $second$ $sample$, $Genos$ $can$ $only$ $destroy$ $one$ $gemstone$ $at$ $a$ $time$, $so$ $destroying$ $three$ $gemstones $$takes$ $three$ $seconds.$ $input$ 1271 4 4 2 3 2 1 $output$ 12 $In$ $the$ $third$ $sample$, $to$ $achieve$ $the$ $optimal$ $time$ $of$ $two$ $seconds$, $destroy$ $palindrome$ $4$ $4$ $first$ $and$ $then$ $destroy$ $palindrome$ $1$ $2$ $3$ $2$ $1$. 解题思路：这是一道 区间 $dp$ 状态方程：$dp[i][j]$ 代表完全删除区间 $(i,j)$ 最少需要多少次操作？ 转移方程： 区间 $(i,j)$ 可以由 区间 $(i,k)$ + 区间 $(k + 1,j)$ 转移而来。 当 $c[i]$ = $c[j]$ 时，区间 $(i,j)$ 也可以由 区间 $(i + 1,j - 1)$ 转移而来。（需要注意的是：当 $i + 1 = j$ 时，直接 $dp[i][j]$ = 1，否则会出现 $i + 1 &gt; j - 1$ 的情况） 小思考1：为什么最外层是枚举 区间长度，而不是直接枚举 区间端点 $l,r$ 呢？ 答：因为我们转移的时候是从 小区间 转移到 大区间 的。 小思考2： 当 $c[i] = c[j]$ 时，为什么 区间 $(i,j)$ 是直接由 区间 $(i + 1,j - 1) $ 转移而来，而不是由 区间 $(i + 1, j - 1)$ $+ $ $1$ 转移而来？ 答：因为，若完全删除 区间 $(i + 1,j - 1)$ 最少需要 $k$ 次操作，那么我们可以在前 $k - 1$ 次操作删掉 区间 $(i + 1,j - 1)$ 的 $k - 1$ 部分，剩下的一部分可以与 $c[i],c[j]$ 形成一个回文串，最后再一起删掉,所以总操作次数还是 $k$ 次。 最后答案：$dp[1][n] $ 。 AC代码：12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1 &lt;&lt; 30;int c[505],dp[505][505];// dp[i][j] : 完全删除区间 (i,j) 最少需要多少次操作？int main()&#123; int n;cin &gt;&gt; n; memset(dp,0x3f,sizeof(dp));// 初始化为正无穷。 for(int i = 1;i &lt;= n;i++) cin &gt;&gt; c[i], dp[i][i] = 1;// 删除一个数时需要一次操作。 for(int len = 2;len &lt;= n;len++)&#123;// 枚举区间长度。 for(int l = 1;l &lt;= n - len + 1;l++)&#123;//枚举左端点。 int r = l + len - 1;//右端点。 for(int k = l;k &lt; r;k++)&#123; dp[l][r] = min(dp[l][r],dp[l][k] + dp[k + 1][r]); // 代表区间(l,r) 可以由 (l,k) + (k + 1,r) 转移。 &#125; if(c[l] == c[r])&#123;//当 a[l] = a[r]时。 if(l + 1 == r) dp[l][r] = 1;//若相邻,则需要一次操作。 dp[l][r] = min(dp[l][r],dp[l + 1][r - 1]);// (l,r) 当然可以由 (l + 1,r - 1) 转移。 &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>区间DP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法]]></title>
    <url>%2F2018%2F03%2F20%2FMarkdown-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&lt;span id=&quot;inline-blue&quot;&gt; 站点配置文件 &lt;/span&gt; 站点配置文件 &lt;span id=&quot;inline-purple&quot;&gt; 主题配置文件 &lt;/span&gt; 主题配置文件 &lt;span id=&quot;inline-yellow&quot;&gt; 站点配置文件 &lt;/span&gt; 站点配置文件 &lt;span id=&quot;inline-green&quot;&gt; 主题配置文件 &lt;/span&gt; ​ 主题配置文件]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-C-Array Gcd]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-C-Array-Gcd%2F</url>
    <content type="text"><![CDATA[解题思路：​ 我们考虑到1操作也就是移除连续的一段区间的元素只能操作一次，而且长度是小于n的，那么最后得到的序列肯定是含有第一个元素或者是最后一个元素，那么根据这个性质我们就可以将 $a[1], a[1] +1, a[1] - 1, a[n], a[n] + 1, a[n] - 1$， 这6个数质数分解将质因子存在来，然后去枚举质因子， 对于每一个质因子序列里的每一个数成为这个质因子的代价是不同的，如果 $a[i]$ % $p$ = 0, $cost[i]$ = $0$、 ($a[i]$ +1) % $p$ = $0$ || ($a[i]$ - 1) % p = $0$, $cost[i]$ = $B$, 否则 $cost[i]$ = oo。那么这个时候我们就可以 $dp$ 了， $dp[i][0]$ 表示从一到 $i $ 这个位置还没有进行1操作的最小花费。$dp[i][1]$ 表示从一到 $i$ 这个位置正在进行1操作的最小花费。$dp[i][2]$ 表示从一到 $i$ 这个位置已经结束1操作了的最小花费。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;const int MaxN = 1e6;typedef long long LL;const LL Max = 1000000000000000000;using namespace std;LL n;LL a, b, c[MaxN + 5], dp[MaxN + 5][4];LL cost[MaxN + 5];vector &lt;LL&gt; G;void G_insert(LL x)&#123; for(LL i = 2;i * i &lt;= x;i++)&#123; if(x % i == 0)&#123; G.push_back(i); while(x % i == 0) x /= i; &#125; &#125; if(x != 1) G.push_back(x);&#125;void Init()&#123; G.clear(); for(int i = 1;i &lt;= n;i++) scanf("%I64d" , &amp;c[i]); for(LL i = -1;i &lt;= 1;i++) G_insert(c[1] + i); for(LL i = -1;i &lt;= 1;i++) G_insert(c[n] + i);&#125;LL Work(LL x)&#123; for(int i = 1;i &lt;= n;i++)&#123; cost[i] = dp[i][0] = dp[i][1] = dp[i][2] = 1LL &lt;&lt; 40; if(c[i] % x == 0) cost[i] = 0; else if((c[i] - 1) % x == 0 || (c[i] + 1) % x == 0) cost[i] = b; &#125; dp[0][0] = dp[0][1] = dp[0][2] = 0; for(int i = 1;i &lt;= n;i++)&#123; dp[i][0] = dp[i - 1][0] + cost[i]; dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a; dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + cost[i]; &#125; return min(dp[n][0] , min(dp[n][1], dp[n][2]));&#125;void Solve()&#123; LL ans = 1LL &lt;&lt; 60; for(int i = 0;i &lt; G.size();i++)&#123; ans = min(ans , Work(G[i])); &#125; printf("%I64d\n" , ans);&#125;int main()&#123; while(~scanf("%I64d%I64d%I64d" , &amp;n , &amp;a , &amp;b))&#123; Init(); Solve(); &#125;&#125;]]></content>
      <categories>
        <category>四校联赛</category>
      </categories>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-D-D商店]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-D-D%E5%95%86%E5%BA%97%2F</url>
    <content type="text"><![CDATA[题目大意：​ 先输入 $n，k$ 分别代表有 $n$ 天，可以让任意 $k$ 天的的物品数量翻倍(每天最多只能翻一次）。接下来有 $n$ 行，第 $i$ 行有两个数 $ai，bi$ 分别代表在第 $i$ 天有 $ai$ 件物品，有 $bi$ 个顾客。每个顾客都会买一件物品。问 n 天后最多卖出多少件物品? 数据范围：$1 \leq n \leq 10^5$ $0 \leq k \leq n$ $1 \leq a_i ,bi\leq 10^9$ 解题思路： 当天的存货量大于等于需求量的时候，这一天的存货量是不需要翻倍的。 当天存货量小于需求量的时候，先让这一天的存货量翻倍，求出当天 ”可增加“ 的销售量，然后根据可增加的销售量从大到小排序，选出前 $k$ 天。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;LL a[maxn],b[maxn],s[maxn];LL cmp(LL x,LL y)&#123; return x &gt; y;&#125;int main()&#123; int n,k; LL ans = 0,sum; scanf("%d %d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++)&#123; scanf("%I64d %I64d",&amp;a[i],&amp;b[i]); if(b[i] &gt; a[i])&#123; if(2 * a[i] &lt;= b[i]) s[i] = a[i]; else s[i] = b[i] - a[i]; &#125; else&#123; s[i] = 0; a[i] = b[i]; &#125; &#125; sort(s + 1,s + n + 1,cmp); for(int i = 1;i &lt;= k;i++) ans += s[i]; for(int i = 1;i &lt;= n;i++) ans += a[i]; printf("%I64d",ans);&#125;]]></content>
      <categories>
        <category>四校联赛</category>
      </categories>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces911D---Inversion Counting]]></title>
    <url>%2F2018%2F03%2F16%2FCodeforces911D---Inversion%20Counting%2F</url>
    <content type="text"><![CDATA[题目大意：给你 $n$ 个数，和 $m$ 个操作询问，每个询问给你 $l,r$ 两个数，问你反转 $l,r$ 区间的元素后，整个序列的逆序对的个数是奇数个还是偶数个，奇数个输出 $odd$ ,偶数个则输出 $even$ ,该逆序对以从小到大为标准次序，反转后不会恢复为原序列，且保证 $n$ 个数中每个数都不相同。 数据范围$1 \leq n \leq 1500,1 \leq m \leq 2 \cdot 10^5,1 \leq l_i \leq r_i \leq n,1 \leq a_i \leq n;​$ 解题思路：因为要求每次操作后逆序对的对数的奇偶性，如果想暴力做的话，每次对序列进行反转就是 $O(n)$ 的复杂度，还得重新求总逆序对个数，总复杂度就变为了 $O(n^{2}\cdot{m})$ ，这显然会 $TLE$ 的，所以得换个想法，我们先求出初始序列的总逆序对个数 $res$ ，根据 $[l,r]$ 区间逆序对的变化转换为总逆序对个数，但是真正的个数我们其实并不太需要，只需要知道奇偶性就行了；我们知道一个长度为len长的序列，它的逆序对最多为 $len\cdot(len-1)/2$ (假如该序列为从大到小排序，即总逆序对个数为 ($1+2+3+\dots+(len-1)=len\cdot(len-1)/2$) 暂且称为满逆序对,那么现逆序对个数即与满逆序对个数有关，若满逆序对个数为偶数个，那么现逆序对奇偶性与原逆序对相同，即为加减偶数个数，可以用 $len\cdot(len-1)/2$ 代替，否则当满逆序对个数为奇数个时，那么现逆序对奇偶性与原逆序对相反，即为加减奇数个，也可用 $len\cdot(len-1)/2$ 代替，所以每次只需要将 $res+=len\cdot(len-1)/2$ 后就可以直接判断奇偶性，$O(1)$ 出答案。 AC代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1500;int n, m, cnt;int a[maxn + 5];int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) if(a[i] &gt; a[j])cnt++; &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); cnt += (r - l + 1) * (r - l) / 2; if(cnt &amp; 1)printf("odd\n"); else printf("even\n"); &#125; return 0;&#125; 题目链接：Go to!]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2FHELLO%20WORLD%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
