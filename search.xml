<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四校联赛2-D-D商店]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-D-D%E5%95%86%E5%BA%97%2F</url>
    <content type="text"><![CDATA[题目大意：​ 先输入 $n，k$ 分别代表有 $n$ 天，可以让任意 $k$ 天的的物品数量翻倍(每天最多只能翻一次）。接下来有 $n$ 行，第 $i$ 行有两个数 $ai，bi$ 分别代表在第 $i$ 天有 $ai$ 件物品，有 $bi$ 个顾客。每个顾客都会买一件物品。问 n 天后最多卖出多少件物品? 数据范围：$1 \leq n \leq 10^5$ $0 \leq k \leq n$ $1 \leq a_i ,bi\leq 10^9$ 解题思路： 当天的存货量大于等于需求量的时候，这一天的存货量是不需要翻倍的。 当天存货量小于需求量的时候，先让这一天的存货量翻倍，求出当天 ”可增加“ 的销售量，然后根据可增加的销售量从大到小排序，选出前 $k$ 天。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;LL a[maxn],b[maxn],s[maxn];LL cmp(LL x,LL y)&#123; return x &gt; y;&#125;int main()&#123; int n,k; LL ans = 0,sum; scanf("%d %d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++)&#123; scanf("%I64d %I64d",&amp;a[i],&amp;b[i]); if(b[i] &gt; a[i])&#123; if(2 * a[i] &lt;= b[i]) s[i] = a[i]; else s[i] = b[i] - a[i]; &#125; else&#123; s[i] = 0; a[i] = b[i]; &#125; &#125; sort(s + 1,s + n + 1,cmp); for(int i = 1;i &lt;= k;i++) ans += s[i]; for(int i = 1;i &lt;= n;i++) ans += a[i]; printf("%I64d",ans);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces911D---Inversion Counting]]></title>
    <url>%2F2018%2F03%2F16%2FCodeforces911D---Inversion%20Counting%2F</url>
    <content type="text"><![CDATA[题目大意：给你 $n$ 个数，和 $m$ 个操作询问，每个询问给你 $l,r$ 两个数，问你反转 $l,r$ 区间的元素后，整个序列的逆序对的个数是奇数个还是偶数个，奇数个输出 $odd$ ,偶数个则输出 $even$ ,该逆序对以从小到大为标准次序，反转后不会恢复为原序列，且保证 $n$ 个数中每个数都不相同。 数据范围$1 \leq n \leq 1500,1 \leq m \leq 2 \cdot 10^5,1 \leq l_i \leq r_i \leq n,1 \leq a_i \leq n;​$ 解题思路：因为要求每次操作后逆序对的对数的奇偶性，如果想暴力做的话，每次对序列进行反转就是 $O(n)$ 的复杂度，还得重新求总逆序对个数，总复杂度就变为了 $O(n^{2}\cdot{m})$ ，这显然会 $TLE$ 的，所以得换个想法，我们先求出初始序列的总逆序对个数 $res$ ，根据 $[l,r]$ 区间逆序对的变化转换为总逆序对个数，但是真正的个数我们其实并不太需要，只需要知道奇偶性就行了；我们知道一个长度为len长的序列，它的逆序对最多为 $len\cdot(len-1)/2$ (假如该序列为从大到小排序，即总逆序对个数为 ($1+2+3+\dots+(len-1)=len\cdot(len-1)/2$) 暂且称为满逆序对,那么现逆序对个数即与满逆序对个数有关，若满逆序对个数为偶数个，那么现逆序对奇偶性与原逆序对相同，即为加减偶数个数，可以用 $len\cdot(len-1)/2$ 代替，否则当满逆序对个数为奇数个时，那么现逆序对奇偶性与原逆序对相反，即为加减奇数个，也可用 $len\cdot(len-1)/2$ 代替，所以每次只需要将 $res+=len\cdot(len-1)/2$ 后就可以直接判断奇偶性，$O(1)$ 出答案。 AC代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1500;int n, m, cnt;int a[maxn + 5];int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) if(a[i] &gt; a[j])cnt++; &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); cnt += (r - l + 1) * (r - l) / 2; if(cnt &amp; 1)printf("odd\n"); else printf("even\n"); &#125; return 0;&#125; 题目链接：Go to!]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2FHELLO%20WORLD%2F</url>
    <content type="text"></content>
  </entry>
</search>
