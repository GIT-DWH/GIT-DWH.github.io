<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络流(最大流)模板题]]></title>
    <url>%2F2018%2F07%2F08%2F%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[题意:现在有m个池塘(从1到m开始编号,1为源点,m为汇点),及n条有向水渠,给出这n条水渠所连接的点和所能流过的最大流量，求从源点到汇点能流过的最大流量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110InputThe input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. OutputFor each case, output a single integer, the maximum rate at which water may emptied from the pond. Sample Input5 41 2 401 4 202 4 202 3 303 4 10 Sample Output50 SourceUSACO 93 Recommendlwg#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;int pre[2 * maxn],last[maxn],other[2 * maxn],deep[maxn];LL cost[maxn];int all = -1,n,m;int aim;void build(int x,int y,LL z)&#123; pre[++all] = last[x]; last[x] = all; other[all] = y; cost[all] = z;&#125;bool Bfs(int S,int T)&#123; memset(deep,0,sizeof(deep)); deep[S] = 1; queue&lt;int&gt; seq; seq.push(S); while(!seq.empty())&#123; int x = seq.front(); seq.pop(); int dt = last[x]; while(dt != -1)&#123; int dr = other[dt]; if(!deep[dr] &amp;&amp; cost[dt])&#123; deep[dr] = deep[x] + 1; seq.push(dr); &#125; dt = pre[dt]; &#125; &#125; return deep[T];&#125;LL dfs(int now,LL fl)&#123; if(now == aim) return fl; LL f = 0; int dt = last[now]; while(dt != -1)&#123; int dr = other[dt]; if(cost[dt] &amp;&amp; deep[dr] == deep[now] + 1)&#123; LL x = dfs(dr,min(fl,cost[dt])); cost[dt] -= x; cost[dt ^ 1] += x; fl -= x; f += x; &#125; dt = pre[dt]; &#125; if(!f) deep[now] = -2; return f;&#125;LL Dinic(int S,int T)&#123; aim = T;LL sum = 0; while(Bfs(S,T))&#123; sum += dfs(S,1LL &lt;&lt; 60); &#125; return sum;&#125;int main()&#123; while(~scanf("%d %d",&amp;m,&amp;n))&#123; memset(last,-1,sizeof(last)); all = -1; for(int i = 1;i &lt;= m;i++)&#123; int x,y; LL z; scanf("%d %d %lld",&amp;x,&amp;y,&amp;z); build(x,y,z); build(y,x,0); &#125; printf("%lld\n",Dinic(1,n)); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组总结]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一. 最长公共前缀给定一个字符串，询问某两个后缀的最长公共前缀。 算法分析：按照上面所说的做法，求两个后缀的最长公共前缀可以转化为求某个区间上 的最小值。对于这个 RMQ 问题，可以用 O(nlogn)的时间先预处理，以后每次回答询问的时间为 O(1)。所以对于本问题，预处理时间为 O(nlogn)，每次回答询问的时间为 O(1)。如果 RMQ 问题用 O(n)的时间预处理，那么本问题预处理的时间可以做到 O(n)。 123456789101112131415161718192021void RMQ()&#123; for(int i = 0; i &lt;= len;i++) dp[i][0] = lcp[i]; for(int j = 1;j &lt;= 20;j++)&#123; for(int i = 0;i &lt;= len;i++)&#123; if(i + (1 &lt;&lt; j) - 1 &lt;= len)&#123; dp[i][j] = min(dp[i][j - 1],dp[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; &#125;&#125;int Get_RMQ(int L,int R)&#123; if(L &gt; R) L--,swap(L,R); else R--; int kk = (int) log2(1.0 * (R - L + 1)); return min(dp[L][kk],dp[R - (1 &lt;&lt; kk) + 1][kk]);&#125;int main()&#123; int com = Get(Rank[i],Rank[j]);//查询以s[i]和s[j]为开头的最长公共前缀&#125; 二.可重叠最长重复子串给定一个字符串，求最长重复子串，这两个子串可以重叠。算法分析：这道题是后缀数组的一个简单应用。做法比较简单，只需要求 height 数组里的最大值即可。首先求最长重复子串，等价于求两个后缀的最长公共前缀的最大值。因为任意两个后缀的最长公共前缀都是 height 数组里某一段的最小值，那么这个值一定不大于 height 数组里的最大值。所以最长重复子串的长度就是height 数组里的最大值。这个做法的时间复杂度为 O(n)。 三.不可重叠最长重复子串给定一个字符串，求最长重复子串，这两个子串不能重叠。算法分析：这题比上一题稍复杂一点。先二分答案，把题目变成判定性问题：判断是否存在两个长度为 k 的子串是相同的，且不重叠。解决这个问题的关键还是利用height 数组。把排序后的后缀分成若干组，其中每组的后缀之间的 height 值都不小于 k。例如，字符串为“aabaaaab”，当 k=2 时，后缀分成了 4 组，如图 5所示。 容易看出，有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然后对于每组后缀，只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于k。如果有一组满足，则说明存在，否则不存在。整个做法的时间复杂度为O(nlogn)。本题中利用 height 值对后缀进行分组的方法很常用。 1234567891011121314151617181920212223242526272829303132Sample Input8 21 2 3 2 3 2 3 1 Sample Output4bool check(int mid)&#123; int sum = 0; for (int i = n + 1; i &gt;= 0; i--)&#123; if(lcp[i] &lt; mid) sum = 0; else&#123; sum++; if(sum + 1 &gt;= m) return 1; &#125; &#125; return 0;&#125;int main()&#123; scanf("%d %d",&amp;n,&amp;m); for(int i = 0;i &lt; n;i++) scanf("%d",&amp;s[i]); Creat_sa(); Creat_lcp(); int l = 1,r = n,ans = 1; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans);&#125; 四.可重叠的 k 次最长重复子串给定一个字符串，求至少出现 k 次的最长重复子串，这 k 个子串可以重叠。算法分析：这题的做法和上一题差不多，也是先二分答案，然后将后缀分成若干组。不同的是，这里要判断的是有没有一个组的后缀个数不小于 k。如果有，那么存k 个相同的子串满足条件，否则不存在。这个做法的时间复杂度为 O(nlogn)。 五.不相同的子串的个数1234567891011121314int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; Init(); scanf("%s",s); len = strlen(s); Creat_sa(); Creat_lcp(); LL n = len; for(int i = 0;i &lt;= len;i++) sum += lcp[i]; printf("%lld\n",n * (n + 1LL) / 2LL - sum); &#125; return 0;&#125; 六.重复次数最多的连续重复子串给定一个字符串，求重复次数最多的连续重复子串。算法分析：先穷举长度 L，然后求长度为 L 的子串最多能连续出现几次。首先连续出现1 次是肯定可以的，所以这里只考虑至少 2 次的情况。假设在原字符串中连续出现 2次，记这个子字符串为 S，那么 S 肯定包括了字符 r[0], r[L], r[L2],r[L3], ……中的某相邻的两个。所以只须看字符 r[Li]和 r[L(i+1)]往前和往后各能匹配到多远，记这个总长度为 K，那么这里连续出现了 K/L+1 次。最后看最大值是多少。 穷举长度 L 的时间是 n，每次计算的时间是 n/L。所以整个做法的时间复杂度是 O(n/1+n/2+n/3+……+n/n)=O(nlogn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Sample Inputccabababcdaabbccaa#Sample OutputCase 1: abababCase 2: aavoid Solve()&#123; ma = 1;//, ma_len = len; for(int l = 1;l &lt;= len;l++)&#123; int pos1 = 0,pos2 = l,cnt = 0,p1,p2; while(pos2 &lt; len)&#123; cnt = Get_RMQ(Rank[pos1],Rank[pos2]); p1 = pos1 - (l - cnt % l); p2 = pos2 - (l - cnt % l); if(p1 &gt;= 0 &amp;&amp; p2 &gt;= 0)&#123; int sum = Get_RMQ(Rank[p1],Rank[p2]); cnt += sum &gt;= l ? (l - cnt % l) : 0; &#125; if(ma == cnt / l + 1) ans.push_back(l); else if(ma &lt; cnt / l + 1)&#123; ans.clear(); ans.push_back(l); ma = cnt / l + 1; &#125; pos1 = pos2,pos2 = pos1 + l; &#125; &#125;&#125;int main()&#123; int t = 0; while(~scanf("%s",s))&#123; if(s[0] == '#') break; memset(dp,0,sizeof(dp)); memset(lcp,0,sizeof(lcp)); memset(Rank,0,sizeof(Rank)); len = strlen(s); Creat_sa(); Creat_lcp(); RMQ(); Solve(); printf("Case %d: ",++t); bool flag = 0; pos = 0,ma_len = 1; //printf("%d\n",ma); //for(int i = 0;i &lt; ans.size();i++) printf("%d\n",ans[i]); for(int i = 1;i &lt;= len;i++)&#123; for(int j = 0;j &lt; ans.size();j++)&#123; if(sa[i] + ans[j] &gt;= len) break; //printf("*%d %d\n",sa[i],ans[j]); if(Get_RMQ(Rank[sa[i]],Rank[sa[i] + ans[j]]) &gt;= (ma - 1) * ans[j])&#123; pos = sa[i]; ma_len = ans[j] * ma; flag = 1; break; &#125; &#125; if(flag) break; &#125; for(int i = 0;i &lt; ma_len;i++)&#123; printf("%c",s[pos + i]); &#125; printf("\n"); &#125;&#125; 七.子串的个数长度不小于 k 的公共子串的个数 给定两个字符串 A 和 B，求长度不小于 k 的公共子串的个数（可以相同）。 样例 1:A=“xx”，B=“xx”，k=1，长度不小于 k 的公共子串的个数是 5。 样例 2:A =“aababaa”，B =“abaabaa”，k=2，长度不小于 k 的公共子串的个数是22。 算法分析: 基本思路是计算 A 的所有后缀和 B 的所有后缀之间的最长公共前缀的长度，把最长公共前缀长度不小于 k 的部分全部加起来。先将两个字符串连起来，中间用一个没有出现过的字符隔开。按 height 值分组后，接下来的工作便是快速的统计每组中后缀之间的最长公共前缀之和。扫描一遍，每遇到一个 B 的后缀就统计与前面的 A 的后缀能产生多少个长度不小于 k 的公共子串，这里 A 的后缀需要用一个单调的栈来高效的维护。然后对 A 也这样做一次。 八.不小于 k 个字符串中的最长子串给定 n 个字符串，求出现在不小于 k 个字符串中的最长子串。 算法分析: 将 n 个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，用和例 3 同样的方法将后缀分成若干组，判断每组的后缀是否出现在不小于 k 个的原串中。这个做法的时间复杂度为O(nlogn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102K = n / 2 Sample Input3abcdefgbcdefghcdefghi3xxxyyyzzz0Sample Outputbcdefgcdefgh?bool check(int mid)&#123; int sum = 0; memset(vis,0,sizeof(vis)); for(int i = 0;i &lt;= len;i++)&#123; if(lcp[i] &lt; mid)&#123; memset(vis,0,sizeof(vis)); sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++; if(sum &gt; n / 2)&#123; return 1; &#125; &#125; &#125; return 0;&#125;int main()&#123; while(~scanf("%d",&amp;n))&#123; if(n == 0) break; s.clear(); int all = 0; memset(tmp,0,sizeof(tmp)); memset(num,0,sizeof(num)); if(n == 1)&#123; cin &gt;&gt; s; cout &lt;&lt; s &lt;&lt; endl &lt;&lt; endl; continue; &#125; int cnt = 200; for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; h; for(int j = 0;j &lt; h.size();j++)&#123; num[all++] = i; s += h[j]; &#125; s += ('A' + (++cnt)),num[all++] = 0; &#125; len = s.size(); Creat_sa(); Creat_lcp(); int l = 1,r = len,ans = -1; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; if(ans == -1) printf("?\n\n"); else&#123; int sum = 0; vector&lt;int&gt; cnt; int pos = -1; memset(vis,0,sizeof(vis)); for(int i = 1;i &lt; len;i++)&#123; if(lcp[i] &lt; ans) &#123; memset(vis,0,sizeof(vis)),sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(x != y)&#123; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++,pos = sa[i]; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++,pos = sa[i + 1]; &#125; if(sum &gt; n / 2 &amp;&amp; lcp[i + 1] &lt; ans) cnt.push_back(pos); &#125; &#125; for(int i = 0;i &lt; cnt.size();i++)&#123; for(int j = cnt[i];j &lt;= cnt[i] + ans - 1;j++)&#123; cout &lt;&lt; s[j]; &#125; cout &lt;&lt; endl; &#125; printf("\n"); &#125; &#125;&#125; 九.每个字符串至少出现两次且不重叠的最长子串给定 n 个字符串，求在每个字符串中至少出现两次且不重叠的最长子串。 算法分析: 做法和上题大同小异，也是先将 n 个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串中至少出现两次，并且在每个原来的字符串中，后缀的起始位置的最大值与最小值之差是否不小于当前答案（判断能否做到不重叠，如果题目中没有不重叠的要求，那么不用做此判断）。这个做法的时间复杂度为 O(nlogn)。 十.出现或反转后出现在每个字符串中的最长子串给定 n 个字符串，求出现或反转后出现在每个字符串中的最长子串。 算法分析: 这题不同的地方在于要判断是否在反转后的字符串中出现。其实这并没有加大题目的难度。只需要先将每个字符串都反过来写一遍，中间用一个互不相同的且没有出现在字符串中的字符隔开，再将 n 个字符串全部连起来，中间也是用一个互不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串或反转后的字符串中出现。这个做法的时间复杂度为 O(nlogn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Sample Input23ABCDBCDFFBRCD2roseorchidSample Output22 bool check(int mid)&#123; int sum = 0; memset(vis,0,sizeof(vis)); for(int i = 0;i &lt;= len + 1;i++)&#123; if(lcp[i] &lt; mid)&#123; memset(vis,0,sizeof(vis)); sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++; if(sum == n) return 1; &#125; &#125; return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); s.clear(); int all = 0; int cnt = 200; memset(tmp,0,sizeof(tmp)); memset(num,0,sizeof(num)); for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; h; for(int j = 0;j &lt; h.size();j++)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt)); num[all++] = 0; for(int j = h.size() - 1;j &gt;= 0;j--)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt)); num[all++] = 0; &#125; len = s.size(); Creat_sa(); Creat_lcp(); int l = 1,r = 105,ans = 0; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组-求最长公共子串长度]]></title>
    <url>%2F2018%2F07%2F08%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题意: 求最长公共子串长度（反转也算） Sample Input:1234567823ABCDBCDFFBRCD2roseorchid Sample Output:1222 解题思路:把原串和反转后的串连在一起，然后二分长度，分组Check。 AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 2e4 + 5;int sa[maxn],Rank[maxn],lcp[maxn],tmp[maxn];string s,h;int len,k,n;int num[maxn];bool vis[105];bool cmp(int i,int j)&#123; if(Rank[i] != Rank[j]) return Rank[i] &lt; Rank[j]; else&#123; int ri = i + k &lt;= len ? Rank[i + k] : -1; int rj = j + k &lt;= len ? Rank[j + k] : -1; return ri &lt; rj; &#125;&#125;void Creat_sa()&#123; for(int i = 0;i &lt;= len;i++)&#123; sa[i] = i; Rank[i] = i &lt; len ? s[i] : -1; &#125; for(k = 1;k &lt;= len;k *= 2)&#123; sort(sa,sa + len + 1,cmp); tmp[sa[0]] = 0; for(int i = 1;i &lt;= len;i++)&#123; tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1],sa[i]) ? 1 : 0); &#125; for(int i = 0;i &lt;= len;i++) Rank[i] = tmp[i]; &#125;&#125;void Creat_lcp()&#123; for(int i = 0;i &lt;= len;i++) Rank[sa[i]] = i; int h = 0; lcp[0] = 0; for(int i = 0;i &lt;= len;i++)&#123; int j = sa[Rank[i] - 1]; if(h &gt; 0) h--; for(;i + h &lt; len &amp;&amp; j + h &lt; len;h++)&#123; if(s[i + h] != s[j + h]) break; &#125; lcp[Rank[i] - 1] = h; &#125;&#125;bool check(int mid)&#123; int sum = 0; memset(vis,0,sizeof(vis)); for(int i = 0;i &lt;= len + 1;i++)&#123; if(lcp[i] &lt; mid)&#123; memset(vis,0,sizeof(vis)); sum = 0; &#125; else&#123; int x = num[sa[i]]; int y = num[sa[i + 1]]; if(!vis[x] &amp;&amp; x != 0) vis[x] = 1,sum++; if(!vis[y] &amp;&amp; y != 0) vis[y] = 1,sum++; if(sum == n) return 1; &#125; &#125; return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); s.clear(); int all = 0; int cnt = 200; memset(tmp,0,sizeof(tmp)); memset(num,0,sizeof(num)); for(int i = 1;i &lt;= n;i++)&#123; cin &gt;&gt; h; for(int j = 0;j &lt; h.size();j++)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt));//用从未出现过的字符相连 num[all++] = 0; for(int j = h.size() - 1;j &gt;= 0;j--)&#123; num[all++] = i; s += (h[j]); &#125; s += ('A' + (++cnt)); num[all++] = 0; &#125; len = s.size(); Creat_sa(); Creat_lcp(); int l = 1,r = 105,ans = 0; while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) ans = mid,l = mid + 1; else r = mid - 1; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-2955-Robberies(01背包，逆向思维)]]></title>
    <url>%2F2018%2F07%2F08%2FHDU-2955-Robberies(01%E8%83%8C%E5%8C%85%EF%BC%8C%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4)%2F</url>
    <content type="text"><![CDATA[题意： 输入一个 t ，表示有 t 组数据。 每组数据先输入 一个 P 和 一个 n。 P 代表被抓的概率需要低于 P，n 代表有 n 个银行。 接下来 n 行的每行输入一个 w 和 p。 w 代表当前银行所有的金额，p 代码当前银行被抓的概率。 问：小偷在被抓的概率低于 P 的情况下，最多能偷多少钱？ Sample Input:1234567891011121314151630.04 31 0.022 0.033 0.050.06 32 0.032 0.033 0.050.10 31 0.032 0.023 0.05 Sample Output:123246 数据范围：$ 0 &lt; T &lt;= 100$$0.0 &lt;= P &lt;= 1.0$$0 &lt; N &lt;= 100$$0 &lt; Mj &lt;= 100$$0.0 &lt;= Pj &lt;= 1.0$ 解题思路： 被抓概率 = 1 - 不被抓概率，所以只要 不被抓概率 &gt;= 1 - P。 01背包。 dp[i] : 偷到 i 金额的钱，而不被抓的最大概率。 dp[0] 初始化为 1.0 , 因为不偷任何东西时，不被转最大概率为 1.0。 转移方程：${dp[j] = dp[j - w[i]] * (1.0 - p[i]);}$ 最后答案就在满足不被抓概率 &gt;= 1 - P 中，取最大金额。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;double dp[10005],p[105];int w[105];int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; double P; int n; scanf("%lf %d",&amp;P,&amp;n); P = 1.0 - P; for(int i = 1;i &lt;= n;i++) scanf("%d %lf",&amp;w[i],&amp;p[i]); memset(dp,0,sizeof(dp)); dp[0] = 1.0; for(int i = 1;i &lt;= n;i++)&#123; for(int j = 10000;j &gt;= w[i];j--)&#123; if(dp[j] &lt; dp[j - w[i]] * (1.0 - p[i]))&#123; dp[j] = dp[j - w[i]] * (1.0 - p[i]); &#125; &#125; &#125; int sum = 0; for(int i = 0;i &lt;= 10000;i++)&#123; if(dp[i] &gt;= P) sum = max(sum,i); &#125; printf("%d\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>01背包</tag>
        <tag>逆向思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2844 - Coins (多重背包,dp）]]></title>
    <url>%2F2018%2F07%2F08%2FHDU%20-%202844%20-%20Coins%20(%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%2Cdp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： 多组输入。每组数据先输入一个 n , m 。 n : 有 n 种硬币； m : 所选硬币总和不超过 m ; 接下来输入 A1 , A2 , A3…An。代表第 i 种硬币的面值。 接着再输入 C1 , C2 , C3…Cn。代表第 i 种硬币的数量。 n == 0 &amp;&amp; m == 0 时结束。 问：在1 ~ m 种，有多少面值恰好能由所给的硬币组成？ Sample Input:12345673 101 2 4 2 1 12 51 4 2 10 0 Sample Output:1284 数据范围： $n(1 ≤ n ≤ 100)$ ,$m(m ≤ 100000)$,$(1 ≤ Ai ≤ 100000,1 ≤ Ci ≤ 1000)$ 参考博客：http://blog.csdn.net/u012762625/article/details/43485973http://blog.csdn.net/tinyguyyy/article/details/51203935 AC代码:解题代码①：1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;bool dp[100005];//dp[j] : 前 i 种物品是否能组成 j 。int a[105],c[105],cnt[100005];//cnt[j] : 当组成 j 时，这时第 i 种物品已经用的个数。int main()&#123; int n,m,sum; while(~scanf("%d %d",&amp;n,&amp;m))&#123; memset(dp,0,sizeof(dp)); if(n == 0 &amp;&amp; m == 0) break; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;c[i]); dp[0] = 1,sum = 0; for(int i = 1;i &lt;= n;i++)&#123; memset(cnt,0,sizeof(cnt)); for(int j = a[i];j &lt;= m;j++)&#123; if(!dp[j] &amp;&amp; cnt[j - a[i]] &lt; c[i] &amp;&amp; dp[j - a[i]])&#123; dp[j] = 1; sum++; cnt[j] = cnt[j - a[i]] + 1; &#125; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; 解题代码②:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;bool dp[100005];//dp[j]: 前 i 种物品是否能组成 j 。int a[105],c[105];int n,m,sum;void ZeroOnePack(int cost)&#123; for(int i = m;i &gt;= cost;i--)&#123; dp[i] = max(dp[i],dp[i - cost]); &#125;&#125;void CompletePack(int cost)&#123; for(int i = cost;i &lt;= m;i++)&#123; dp[i] = max(dp[i],dp[i - cost]); &#125;&#125;void MultiPack(int cost,int num)&#123; if(num * cost &gt; m)&#123; CompletePack(cost); &#125; else&#123; int k = 1;//二进制思想 while(k &lt; num)&#123; ZeroOnePack(cost * k); num -= k; k &lt;&lt;= 1; &#125; ZeroOnePack(cost * num); &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;n,&amp;m))&#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;a[i]); for(int i = 1;i &lt;= n;i++) scanf("%d",&amp;c[i]); memset(dp,0,sizeof(dp)); dp[0] = 1,sum = 0; for(int i = 1;i &lt;= n;i++)&#123; MultiPack(a[i],c[i]); &#125; for(int i = 1;i &lt;= m;i++)&#123; if(dp[i]) sum++; &#125; printf("%d\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>多重背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 2159 - FATE(完全背包）]]></title>
    <url>%2F2018%2F07%2F08%2FHDU%20-%202159%20-%20FATE(%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意： 多组数据。每组数据先输入 n，m，k，s。 n : 升级所需要的经验。 m : 所拥有的耐力。 k : 怪的种类。 s : 最多能杀的怪的数量。 接下来有 k 行，每行输入 a , b。 a : 杀死第 i 个怪所能获得的经验。 b : 杀死第 i 个怪所要消耗的耐力。 问：在满足所杀的怪的数量不超过 s , 所消耗的耐力不超过 m 时，最多剩下多少耐力？ Sample Input:12345678910 10 1 101 110 10 1 91 19 10 2 101 12 2 Sample Output:1230-11 数据范围： $(0 &lt; n,m,k,s &lt; 100)$ ,$(0 &lt; a,b &lt; 20)$ 解题思路： 这道题可以转化为完全背包来做。m 等价于背包的容量。a 等价于物品的价值。b 等价于物品的体积。但是这道题有一点要注意的地方，就是题目要求所杀的怪的数量不能超过 s。 所以需要增加一个 cnt[j]。cnt[j] : 前 i 种怪中，花费耐力不超过 j ，并且在获得最多经验时，最少杀的怪的数量。其他就直接按完全背包来做。 dp[j] : 前 i 种怪中，花费耐力不超过 j 时，最多能获得的经验。 转移方程看代码。 最后的答案就是在满足条件下，选一个剩下最多的经验。 优先级：所获经验 &gt; 杀怪数量 AC代码如下：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;int dp[105];// dp[j] : 前 i 种怪中，花费耐力不超过 j 时，最多能获得的经验。int cnt[105];// cnt[j] : 前 i 种怪中，花费耐力不超过 j ，并且在获得最多经验时，最少杀的怪的数量。int a[105],b[105];int main()&#123; int n,m,k,s; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s)&#123; for(int i = 1;i &lt;= k;i++)&#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; &#125; memset(dp,0,sizeof(dp)); memset(cnt,0,sizeof(cnt)); for(int i = 1;i &lt;= k;i++)&#123; for(int j = b[i];j &lt;= m;j++)&#123; if(dp[j] &lt; dp[j - b[i]] + a[i])&#123;//转移方程(优先经验) dp[j] = dp[j - b[i]] + a[i]; cnt[j] = cnt[j - b[i]] + 1; &#125; else if(dp[j] == dp[j - b[i]] + a[i])&#123;//转移方程 cnt[j] = min(cnt[j],cnt[j - b[i]] + 1); &#125; &#125; &#125; int ans = -1; for(int i = 0;i &lt;= m;i++)&#123; if(dp[i] &gt;= n &amp;&amp; cnt[i] &lt;= s) ans = max(m - i,ans); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1864 - 最大报销额 (浮点数 ，一维dp)]]></title>
    <url>%2F2018%2F07%2F08%2FHDU%20-%201864%20-%20%E6%9C%80%E5%A4%A7%E6%8A%A5%E9%94%80%E9%A2%9D%20(%E6%B5%AE%E7%82%B9%E6%95%B0%20%EF%BC%8C%E4%B8%80%E7%BB%B4dp)%2F</url>
    <content type="text"><![CDATA[题意：​ 多组输入。每组先输入 $Q$ 和 $N$（$Q$：最多报销金额，$N$：支票张数。接下来的 $N$ 行，每一行先输入 $m$ （$m$：当前支票上的报销类型数），然后输入 $m$ 个类型及其需报销金额。问：在满足 ： ①每张支票上报销的类型需是 $A$ 或 $B$ 或 $C$。②每张支票 $A$ 类型 或 $B$ 类型 或 $C$ 类型 需报销的各自总金额都不能超过 6000。③每张金额的总需报销金额小于 1000。 的条件下，最多能报销的金额。 Sample Input:12345678910111213141516171819202122232425200.00 3 2 A:23.50 B:100.00 1 C:650.00 3 A:59.99 A:120.00 X:10.00 1200.00 2 2 B:600.00 A:400.00 1 C:200.50 1200.50 3 2 B:600.00 A:400.00 1 C:200.50 1 A:100.00 100.00 0 Sample Output:12345123.50 1000.00 1200.50 数据范围：$ N &lt;= 30$ 解题思路：​ 01背包。因为题目数据是浮点数，答案保留2位小数，所以先将所有数据 100 变为 int 型，以方便计算。*dp[i]:总报销金额不超过 i 下的所能报销的最大金额（初始化都为0）。转移方程参见代码 AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;//因为题目数据是浮点数，答案保留2位小数，所以先将所有数据 * 100 变为 int 型，以方便计算。int dp[3000001];//dp[i]:总报销金额不超过 i 下的所能报销的最大金额。int cost[35];//cost[i]:符合条件的支票所需要报销的金额int main()&#123; double d_sum; int n,m,i_sum; while(scanf("%lf %d",&amp;d_sum,&amp;n) &amp;&amp; n)&#123; int all = 0; i_sum = (int)(d_sum * 100); while(n--)&#123; int sum_A = 0,sum_B = 0,sum_C = 0,sum = 0; bool flag = true; scanf("%d",&amp;m); while(m--)&#123; char type; double d_x; scanf(" %c:%lf",&amp;type,&amp;d_x); if(type == 'A') sum_A += (int)(d_x * 100); else if(type == 'B') sum_B += (int)(d_x * 100); else if(type == 'C') sum_C += (int)(d_x * 100); else flag = false; sum += (int)(d_x * 100); &#125; if(sum &gt; 100000 || sum_A &gt; 60000 || sum_B &gt; 60000 || sum_C &gt; 60000) flag = false; if(flag) cost[++all] = sum; &#125; memset(dp,0,sizeof(dp));//多组清空 for(int i = 1;i &lt;= all;i++)&#123; for(int j = i_sum;j &gt;= cost[i];j--)&#123;//要倒着是因为防止cost[i]被选了多次。 if(dp[j - cost[i]] + cost[i] &gt; dp[j]) dp[j] = dp[j - cost[i]] + cost[i]; &#125; &#125; printf("%.2lf\n",(double) (dp[i_sum] / 100.0)); &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>浮点数</tag>
        <tag>一维dp</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[F.islands (强联通分量 + 缩点）]]></title>
    <url>%2F2018%2F07%2F08%2FF.islands%20(%E5%BC%BA%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F%20%20%2B%20%E7%BC%A9%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题意：给你一个有向图，问最少要添加多少条有向边使图中任意两点可以相互到达。 数据范围：$ (N≤10000)$ ,$M (M≤100000)$ 样例输入：12345678910111224 31 22 33 44 41 21 43 23 4 样例输出：12312 解题思路：​ 强联通分量 + 缩点 后得到一个有向无环图 $DAG$ 。然后求这个 $DAG$ 每个点的入度 $f[]$ 和 出度 $d[]$ ,然后 $all$ ：$DAG$ 中出度为 $0$ 点的个数；$ans$ ： $DAG$ 中入度为 $0$ 点的个数。最后答案 = $max(all,ans)$。注意：当只有一个强联通分量时不用添加边。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e4 + 5;int vis[maxn],low[maxn],dfn[maxn],in[maxn],f[maxn],d[maxn];vector&lt;int&gt; G[maxn * 10];stack&lt;int&gt; st; int n,m,ind,cnt;void Init()&#123; ind = cnt = 0; for(int i = 0;i &lt;= n;i++) G[i].clear(); memset(vis,0,sizeof(vis)); memset(in,0,sizeof(in)); memset(low,0,sizeof(low)); memset(dfn,0,sizeof(dfn)); memset(f,0,sizeof(f)); memset(d,0,sizeof(d));&#125;void dfs(int x)&#123;//求联通分量 + 缩点。 low[x] = dfn[x] = ++ind; st.push(x),vis[x] = 1; for(int i = 0;i &lt; G[x].size();i++)&#123; int v = G[x][i]; if(!dfn[v])&#123; dfs(v); low[x] = min(low[x],low[v]); &#125; else if(vis[v])&#123; low[x] = min(low[x],dfn[v]); &#125; &#125; if(low[x] == dfn[x])&#123; cnt++; while(!st.empty())&#123; int tot = st.top(); st.pop(); vis[tot] = 0; in[tot] = cnt;//在同一连通分量缩成一点 cnt。(同时cnt的值也等于图中连通分量的个数) if(tot == x) break; &#125; &#125;&#125;void slove()&#123;//求缩点后，每个连通分量的 入度 f[] 和 出度 d[]。 for(int i = 1;i &lt;= n;i++)&#123; for(int j = 0;j &lt; G[i].size();j++)&#123; int v = G[i][j]; if(in[i] != in[v])&#123; d[in[i]]++; f[in[v]]++; &#125; &#125; &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; Init(); int x,y; scanf("%d %d",&amp;n,&amp;m); for(int i = 1;i &lt;= m;i++)&#123; scanf("%d %d",&amp;x,&amp;y); G[x].push_back(y); &#125; for(int i = 1;i &lt;= n;i++)&#123; if(!dfn[i]) dfs(i); &#125; if(cnt == 1)&#123; printf("0\n"); continue; &#125; slove(); int all,ans; all = ans = 0; for(int i = 1;i &lt;= cnt;i++)&#123; if(d[i] == 0) all++; if(f[i] == 0) ans++; &#125; printf("%d\n",max(ans,all)); &#125;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>强联通分量</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2018%2F04%2F20%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2222题目大意：给你 $n$ 个模式串和一个文本串，问文本串中一共出现过多少个模式串？ 样例：$Sample Input$ 12345678910111225shehesayshrheryasherhs1aaaaaa $Sample Output$ 1231 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 1e6 + 5;int sind;struct Node&#123; int nxt[26]; int count; int fail; void Init()&#123; memset(nxt,-1,sizeof(nxt)); fail = 0; count = 0; &#125;&#125;s[maxn];void Ins(char *str)&#123; int len = strlen(str); int ind = 0,i,j; for(i = 0;i &lt; len;i++)&#123; j = str[i] - 'a'; if(s[ind].nxt[j] == -1)&#123; s[sind].Init(); s[ind].nxt[j] = sind++; &#125; ind = s[ind].nxt[j]; &#125; s[ind].count++;&#125;void Get_fail()&#123; queue&lt;int&gt;seq; int i,ind = 0,ind_f; for(i = 0;i &lt; 26;i++)&#123; if(s[0].nxt[i] != -1)&#123; seq.push(s[0].nxt[i]); &#125; &#125; while(!seq.empty())&#123; ind = seq.front(); seq.pop(); for(i = 0;i &lt; 26;i++)&#123; if(s[ind].nxt[i] != -1)&#123; seq.push(s[ind].nxt[i]); ind_f = s[ind].fail; while(ind_f &gt; 0 &amp;&amp; s[ind_f].nxt[i] == -1) ind_f = s[ind_f].fail; if(s[ind_f].nxt[i] != -1) ind_f = s[ind_f].nxt[i]; s[s[ind].nxt[i]].fail = ind_f; &#125; &#125; &#125;&#125;int Find(char *des)&#123; int i,j,p,sum = 0,ind = 0; int len = strlen(des); for(i = 0;i &lt; len;i++)&#123; j = des[i] - 'a'; while(ind &gt; 0 &amp;&amp; s[ind].nxt[j] == -1) ind = s[ind].fail; if(s[ind].nxt[j] != -1)&#123; //printf("%d\n",ind); p = s[ind].nxt[j]; //printf("%d\n",p); ind = p; while(p &gt; 0 &amp;&amp; s[p].count != -1)&#123; //printf("%d\n",s[p].count); sum += s[p].count; s[p].count = -1; p = s[p].fail; &#125; &#125; &#125; return sum;&#125;int main()&#123; char str[maxn],des[maxn]; int t; scanf("%d",&amp;t); while(t--)&#123; sind = 1; s[0].Init(); int n; scanf("%d",&amp;n); for(int i = 1;i &lt;= n;i++)&#123; scanf("%s",str); Ins(str); &#125; scanf("%s",des); Get_fail(); //printf("%d\n",s[4].fail); //printf("%d\n",s[1].count); printf("%d\n",Find(des)); &#125;&#125;]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[马拉车总结]]></title>
    <url>%2F2018%2F04%2F11%2F%E9%A9%AC%E6%8B%89%E8%BD%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一.算法过程分析由于回文分为偶回文（比如 $bccb$）和奇回文（比如 $bcacb$），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，在字符间插入一个字符（前提这个字符未出现在串里）。举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文 abba 和一个奇回文 opxpo，被转换为 #a#b#b#a# 和 #o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组 int p[]， p[i] 表示以 ma[i]为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ma[i] $ # a # b # b # a # h # o # p # x # p # p[i] 1 2 1 4 5 2 1 2 1 2 1 2 1 2 1 6 1 2 1 可以看出，p[i]-1 正好是原字符串中最长回文串的长度。 二.定义 R 为以 ma[id] 为中心的最长回文最右边界，也就是 R = id + p[id]。$j$ 与 $i$关于 $id$ 对称，根据回文的性质，p[i] 的值基于以下三种情况得出:​ (1). $j$ 的回文串有一部分在 $id$ 的之外，如下图： ​ 上图中，黑线为 $id$ 的回文，$i$ 与 $j$ 关于 $id$ 对称，红线为 $j$ 的回文。那么根据代码此时p[i] = R-i，即紫线。那么p[i] 还可以更大么？答案是不可能！见下图： 假设右边新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，$a$ 等于 $d$ ，也就是说 $id$ 的回文不仅仅是黑线，而是黑线 + 两条紫线，矛盾，所以假设不成立，故p[i] = R-i，不可以再增加一分。 （2）j 回文串全部在 $id$ 的内部，如下图： 此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图： 假设右边新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，$a$ 等于 $b $，也就是说 $j$ 的回文应该再加上 $a$ 和 $b$ ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）$j$ 回文串左端正好与 $id$ 的回文串左端重合，见下图： 此时p[i] = p[j] 或 p[i] = R - i ，并且p[i] 还可以继续增加，所以需要 12while (ma[i - p[i]] == ma[i + p[i]]) p[i]++; 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 110010;char s[maxn];char Ma[maxn * 2];int p[maxn * 2];void Manacher(char s[], int len) &#123; int l = 0; Ma[l++] = '$'; Ma[l++] = '#'; for(int i = 0; i &lt; len; i++) &#123; Ma[l++] = s[i]; Ma[l++] = '#'; &#125; Ma[l] = 0; int pos = 0, R = 0; for(int i = 0; i &lt; l; i++) &#123; if(i &lt; R)p[i] = min(p[pos * 2 - i], R - i); else p[i] = 1; while(Ma[i + p[i]] == Ma[i - p[i]])p[i]++; if(i + p[i] &gt; R) R = i + p[i], pos = i; &#125;&#125;int main() &#123; while(scanf("%s", s) != EOF) &#123; int Max = 0; int len = strlen(s); Manacher(s, len); for(int i = 0; i &lt; 2 * len + 2; i++) &#123; Max = max(Max, p[i] - 1); &#125; printf("%d\n", Max); &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>马拉车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2018%2F04%2F11%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[从大到小：$priority_queue &lt;int,vector,less &gt; p;$ 从小到大：$priority_queue &lt;int,vector,greater &gt; q;$ 优先队列里放 $pair$ :$typede$ $pair&lt;LL, int&gt; PII;$$vector ans;$$priority_queue&lt;PII, vector, greater &gt;que;$ 这里是首先让第一元素从小到大排序，当第一元素相等时，再按第二元素从大到小排序。 优先队列自定义重载：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;struct X&#123; int a,b; X () &#123;&#125; X (int aa,int bb) &#123; a = aa,b = bb; &#125; friend bool operator &lt; (const X A, const X B)&#123; if(A.a == B.a) return A.b &gt; B.b; //这里是反过来的，小于就是大于，大于就是小于。 else return A.a &gt; B.a; &#125;&#125;;X ans[maxn];priority_queue &lt;X&gt; pq;int main()&#123; ans[1].a = 1; ans[1].b = 2; ans[2].a = 2; ans[2].b = 1; ans[3].a = 1; ans[3].b = 3; pq.push(ans[1]); pq.push(ans[3]); pq.push(ans[2]); while(!pq.empty())&#123; X k = pq.top(); pq.pop(); printf("%d %d\n",k.a,k.b); &#125;&#125;输出：1 21 32 1]]></content>
      <categories>
        <category>队列</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名规范]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Codeforces:例如： $CF-div2-465.cpp$ $CF-E-div2-40.cpp$ ​ Atcoder:例如： $AT-R-093.cpp$ $AT-B-093.cpp$ $AT-G-093.cpp$ POJ:例如： $POJ$ $-$ $4745.cpp$]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>命名规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2F2018%2F03%2F24%2FDijkstra%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int inf = 1 &lt;&lt; 30;const LL INF = 1LL &lt;&lt; 60;const int MaxN = 2000;int n, T;int all;int pre[2 * MaxN + 5], last[MaxN + 5], other[2 * MaxN + 5];int cost[2 * MaxN + 5];int dis[MaxN + 5];struct Node &#123; int id, d; Node () &#123;&#125; Node (int a, int b) : id(a), d(b) &#123;&#125; bool friend operator &lt; (Node a, Node b) &#123; return a.d &gt; b.d; &#125;&#125;;void build(int x, int y, int w) &#123; pre[++all] = last[x]; last[x] = all; other[all] = y; cost[all] = w;&#125;void Dijkstra(int s) &#123; for(int i = 1; i &lt;= n; i++) dis[i] = inf; dis[s] = 0; priority_queue &lt;Node&gt; pq; pq.push(Node(s, 0)); while(!pq.empty()) &#123; Node now = pq.top(); pq.pop(); int ed = last[now.id]; while(ed != -1) &#123; int dr = other[ed]; if(dis[now.id] + cost[ed] &lt; dis[dr]) &#123; dis[dr] = dis[now.id] + cost[ed]; pq.push(Node(dr, dis[dr])); &#125; ed = pre[ed]; &#125; &#125;&#125;int main() &#123; while(scanf("%d %d", &amp;T, &amp;n) != EOF) &#123; all = -1; memset(last, -1, sizeof(last)); for(int i = 1; i &lt;= T; i++) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); build(u, v, w); build(v, u, w); &#125; Dijkstra(1); printf("%d\n", dis[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1141-Brackets Sequence]]></title>
    <url>%2F2018%2F03%2F23%2FPOJ-1141-Brackets-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接：Go! 题目大意：​ 给你一个长度不超过 $100$ 且只包含 $( , ) , [ , ]$ 四种字符的字符串 $s$，添加 最少 的字符使其变成一个合法的字符串，输出这个合法的字符串。 合法字符串的定义： $Empty$ $sequence$ $is$ $a$ $regular$ $sequence. $ $If$ $S$ $is$ $a$ $regular$ $sequence$, $then$ $(S)$ $and$ $[S]$ $are$ $both$ $regular$ $sequences. $ $If$ $A$ $and$ $B$ $are$ $regular$ $sequences$, $then$ $AB$ $is$ $a$ $regular$ $sequence$. 样例：$Sample$ $ Input$ 1([(] $Sample$ $ Output$ 1()[()] 解题思路：这是一道 区间 $dp$ (路径还原) 状态方程 : $dp[i][j]$ 代表使 区间 $(i,j)$ 形成一个合法的字符串最少需要添加多的字符串？ ​ $path[i][j]$ 代表添加最少的字符使 区间 $(i,j)$ 形成一个合法的字符串的路径选择。 若 $path[i][j]$ $=$ $-1$ ,表示头尾。 若 $path[i][j]$ $=$ $k$ ($k$ != $-1$ ) ,表示由 区间 $(i,k)$ 和 区间 ($k + 1$ ,$j$) 而来。 转移方程： 区间 $(i,j)$ 可以由 区间 $(i,k)$ + 区间 $(k + 1,j)$ 转移而来。 当 $s[i]$ = $s[j]$ 时，区间 $(i,j)$ 也可以由 区间 $(i + 1,j - 1)$ 转移而来。（需要注意的是：当 $i + 1 = j$ 时，直接 $dp[i][j]$ = $0$，否则会出现 $i + 1 &gt; j - 1$ 的情况） 小思考：为什么最外层是枚举 区间长度，而不是直接枚举 区间端点 $l,r$ 呢？ 答：因为我们转移的时候是从 小区间 转移到 大区间 的。 最后答案：根据 $path[i][j]$ 记录的值，用递归还原路径。（详情请看代码） AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 105;int dp[maxn][maxn],path[maxn][maxn];char s[maxn];void dfs(int l,int r)&#123; if(l &gt; r) return; if(l == r)&#123; if(s[l] == '(' || s[l] == ')') cout &lt;&lt; "()"; else cout &lt;&lt; "[]"; return; &#125; if(path[l][r] == -1)&#123; cout &lt;&lt; s[l];//先输出左端点, dfs(l + 1,r - 1);//再输出中间, cout &lt;&lt; s[r];//最后输出右端点。 &#125; else&#123; int k = path[l][r];//分两部分输出。 dfs(l,k); dfs(k + 1,r); &#125;&#125;int main()&#123; int n; while(gets(s + 1))&#123; n = strlen(s + 1); memset(dp,0x3f,sizeof(dp)); memset(path,0,sizeof(path)); for(int i = 1;i &lt;= n;i++) dp[i][i] = 1;//初始化：自己当然初始化为 1,其他初始化为无穷大。 for(int len = 2;len &lt;= n;len++)&#123; for(int l = 1;l &lt;= n - len + 1;l++)&#123; int r = len + l - 1; if((s[l] == '(' &amp;&amp; s[r] == ')') || (s[l] == '[' &amp;&amp; s[r] == ']'))&#123; if(dp[l + 1][r - 1] &lt; dp[l][r])&#123; dp[l][r] = dp[l + 1][r - 1]; path[l][r] = -1; &#125; else if(l + 1 == r)&#123; dp[l][r] = 0; path[l][r] = -1; &#125; &#125; for(int k = l;k &lt; r;k++)&#123; if(dp[l][k] + dp[k + 1][r] &lt; dp[l][r])&#123; dp[l][r] = dp[l][k] + dp[k + 1][r]; path[l][r] = k; &#125; &#125; &#125; &#125; dfs(1,n); cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces-336-div2-D-Zuma]]></title>
    <url>%2F2018%2F03%2F20%2FCodeforces-336-div2-D-Zuma%2F</url>
    <content type="text"><![CDATA[题目链接：Go! 题目大意：​ 给你一个长度为 $n$ 的序列 $c$，每次操作删去当前序列的一个回文串。问：把序列全部删完，最少需要多少次的操作? 数据范围：$1 \leq n \leq 10^5$ $1 \leq c_i \leq n$ 样例：$input$ 1231 2 1 $output$ 11 $In$ $the$ $first$ $sample$, $Genos$ $can$ $destroy$ $the$ $entire$ $line$ $in$ $one$ $second.$ $input$ 1231 2 3 $output$ 13 $In$ $the$ $second$ $sample$, $Genos$ $can$ $only$ $destroy$ $one$ $gemstone$ $at$ $a$ $time$, $so$ $destroying$ $three$ $gemstones $$takes$ $three$ $seconds.$ $input$ 1271 4 4 2 3 2 1 $output$ 12 $In$ $the$ $third$ $sample$, $to$ $achieve$ $the$ $optimal$ $time$ $of$ $two$ $seconds$, $destroy$ $palindrome$ $4$ $4$ $first$ $and$ $then$ $destroy$ $palindrome$ $1$ $2$ $3$ $2$ $1$. 解题思路：这是一道 区间 $dp$ 状态方程：$dp[i][j]$ 代表完全删除区间 $(i,j)$ 最少需要多少次操作？ 转移方程： 区间 $(i,j)$ 可以由 区间 $(i,k)$ + 区间 $(k + 1,j)$ 转移而来。 当 $c[i]$ = $c[j]$ 时，区间 $(i,j)$ 也可以由 区间 $(i + 1,j - 1)$ 转移而来。（需要注意的是：当 $i + 1 = j$ 时，直接 $dp[i][j]$ = 1，否则会出现 $i + 1 &gt; j - 1$ 的情况） 小思考1：为什么最外层是枚举 区间长度，而不是直接枚举 区间端点 $l,r$ 呢？ 答：因为我们转移的时候是从 小区间 转移到 大区间 的。 小思考2： 当 $c[i] = c[j]$ 时，为什么 区间 $(i,j)$ 是直接由 区间 $(i + 1,j - 1) $ 转移而来，而不是由 区间 $(i + 1, j - 1)$ $+ $ $1$ 转移而来？ 答：因为，若完全删除 区间 $(i + 1,j - 1)$ 最少需要 $k$ 次操作，那么我们可以在前 $k - 1$ 次操作删掉 区间 $(i + 1,j - 1)$ 的 $k - 1$ 部分，剩下的一部分可以与 $c[i],c[j]$ 形成一个回文串，最后再一起删掉,所以总操作次数还是 $k$ 次。 最后答案：$dp[1][n] $ 。 AC代码：12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int inf = 1 &lt;&lt; 30;int c[505],dp[505][505];// dp[i][j] : 完全删除区间 (i,j) 最少需要多少次操作？int main()&#123; int n;cin &gt;&gt; n; memset(dp,0x3f,sizeof(dp));// 初始化为正无穷。 for(int i = 1;i &lt;= n;i++) cin &gt;&gt; c[i], dp[i][i] = 1;// 删除一个数时需要一次操作。 for(int len = 2;len &lt;= n;len++)&#123;// 枚举区间长度。 for(int l = 1;l &lt;= n - len + 1;l++)&#123;//枚举左端点。 int r = l + len - 1;//右端点。 for(int k = l;k &lt; r;k++)&#123; dp[l][r] = min(dp[l][r],dp[l][k] + dp[k + 1][r]); // 代表区间(l,r) 可以由 (l,k) + (k + 1,r) 转移。 &#125; if(c[l] == c[r])&#123;//当 a[l] = a[r]时。 if(l + 1 == r) dp[l][r] = 1;//若相邻,则需要一次操作。 dp[l][r] = min(dp[l][r],dp[l + 1][r - 1]);// (l,r) 当然可以由 (l + 1,r - 1) 转移。 &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法]]></title>
    <url>%2F2018%2F03%2F20%2FMarkdown-%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&lt;span id=&quot;inline-blue&quot;&gt; 站点配置文件 &lt;/span&gt; 站点配置文件 &lt;span id=&quot;inline-purple&quot;&gt; 主题配置文件 &lt;/span&gt; 主题配置文件 &lt;span id=&quot;inline-yellow&quot;&gt; 站点配置文件 &lt;/span&gt; 站点配置文件 &lt;span id=&quot;inline-green&quot;&gt; 主题配置文件 &lt;/span&gt; ​ 主题配置文件]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-C-Array Gcd]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-C-Array-Gcd%2F</url>
    <content type="text"><![CDATA[解题思路：​ 我们考虑到1操作也就是移除连续的一段区间的元素只能操作一次，而且长度是小于n的，那么最后得到的序列肯定是含有第一个元素或者是最后一个元素，那么根据这个性质我们就可以将 $a[1], a[1] +1, a[1] - 1, a[n], a[n] + 1, a[n] - 1$， 这6个数质数分解将质因子存在来，然后去枚举质因子， 对于每一个质因子序列里的每一个数成为这个质因子的代价是不同的，如果 $a[i]$ % $p$ = 0, $cost[i]$ = $0$、 ($a[i]$ +1) % $p$ = $0$ || ($a[i]$ - 1) % p = $0$, $cost[i]$ = $B$, 否则 $cost[i]$ = oo。那么这个时候我们就可以 $dp$ 了， $dp[i][0]$ 表示从一到 $i $ 这个位置还没有进行1操作的最小花费。$dp[i][1]$ 表示从一到 $i$ 这个位置正在进行1操作的最小花费。$dp[i][2]$ 表示从一到 $i$ 这个位置已经结束1操作了的最小花费。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;const int MaxN = 1e6;typedef long long LL;const LL Max = 1000000000000000000;using namespace std;LL n;LL a, b, c[MaxN + 5], dp[MaxN + 5][4];LL cost[MaxN + 5];vector &lt;LL&gt; G;void G_insert(LL x)&#123; for(LL i = 2;i * i &lt;= x;i++)&#123; if(x % i == 0)&#123; G.push_back(i); while(x % i == 0) x /= i; &#125; &#125; if(x != 1) G.push_back(x);&#125;void Init()&#123; G.clear(); for(int i = 1;i &lt;= n;i++) scanf("%I64d" , &amp;c[i]); for(LL i = -1;i &lt;= 1;i++) G_insert(c[1] + i); for(LL i = -1;i &lt;= 1;i++) G_insert(c[n] + i);&#125;LL Work(LL x)&#123; for(int i = 1;i &lt;= n;i++)&#123; cost[i] = dp[i][0] = dp[i][1] = dp[i][2] = 1LL &lt;&lt; 40; if(c[i] % x == 0) cost[i] = 0; else if((c[i] - 1) % x == 0 || (c[i] + 1) % x == 0) cost[i] = b; &#125; dp[0][0] = dp[0][1] = dp[0][2] = 0; for(int i = 1;i &lt;= n;i++)&#123; dp[i][0] = dp[i - 1][0] + cost[i]; dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a; dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + cost[i]; &#125; return min(dp[n][0] , min(dp[n][1], dp[n][2]));&#125;void Solve()&#123; LL ans = 1LL &lt;&lt; 60; for(int i = 0;i &lt; G.size();i++)&#123; ans = min(ans , Work(G[i])); &#125; printf("%I64d\n" , ans);&#125;int main()&#123; while(~scanf("%I64d%I64d%I64d" , &amp;n , &amp;a , &amp;b))&#123; Init(); Solve(); &#125;&#125;]]></content>
      <categories>
        <category>四校联赛</category>
      </categories>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-D-D商店]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-D-D%E5%95%86%E5%BA%97%2F</url>
    <content type="text"><![CDATA[题目大意：​ 先输入 $n，k$ 分别代表有 $n$ 天，可以让任意 $k$ 天的的物品数量翻倍(每天最多只能翻一次）。接下来有 $n$ 行，第 $i$ 行有两个数 $ai，bi$ 分别代表在第 $i$ 天有 $ai$ 件物品，有 $bi$ 个顾客。每个顾客都会买一件物品。问 n 天后最多卖出多少件物品? 数据范围：$1 \leq n \leq 10^5$ $0 \leq k \leq n$ $1 \leq a_i ,bi\leq 10^9$ 解题思路： 当天的存货量大于等于需求量的时候，这一天的存货量是不需要翻倍的。 当天存货量小于需求量的时候，先让这一天的存货量翻倍，求出当天 ”可增加“ 的销售量，然后根据可增加的销售量从大到小排序，选出前 $k$ 天。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;LL a[maxn],b[maxn],s[maxn];LL cmp(LL x,LL y)&#123; return x &gt; y;&#125;int main()&#123; int n,k; LL ans = 0,sum; scanf("%d %d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++)&#123; scanf("%I64d %I64d",&amp;a[i],&amp;b[i]); if(b[i] &gt; a[i])&#123; if(2 * a[i] &lt;= b[i]) s[i] = a[i]; else s[i] = b[i] - a[i]; &#125; else&#123; s[i] = 0; a[i] = b[i]; &#125; &#125; sort(s + 1,s + n + 1,cmp); for(int i = 1;i &lt;= k;i++) ans += s[i]; for(int i = 1;i &lt;= n;i++) ans += a[i]; printf("%I64d",ans);&#125;]]></content>
      <categories>
        <category>四校联赛</category>
      </categories>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces911D---Inversion Counting]]></title>
    <url>%2F2018%2F03%2F16%2FCodeforces911D---Inversion%20Counting%2F</url>
    <content type="text"><![CDATA[题目大意：给你 $n$ 个数，和 $m$ 个操作询问，每个询问给你 $l,r$ 两个数，问你反转 $l,r$ 区间的元素后，整个序列的逆序对的个数是奇数个还是偶数个，奇数个输出 $odd$ ,偶数个则输出 $even$ ,该逆序对以从小到大为标准次序，反转后不会恢复为原序列，且保证 $n$ 个数中每个数都不相同。 数据范围$1 \leq n \leq 1500,1 \leq m \leq 2 \cdot 10^5,1 \leq l_i \leq r_i \leq n,1 \leq a_i \leq n;​$ 解题思路：因为要求每次操作后逆序对的对数的奇偶性，如果想暴力做的话，每次对序列进行反转就是 $O(n)$ 的复杂度，还得重新求总逆序对个数，总复杂度就变为了 $O(n^{2}\cdot{m})$ ，这显然会 $TLE$ 的，所以得换个想法，我们先求出初始序列的总逆序对个数 $res$ ，根据 $[l,r]$ 区间逆序对的变化转换为总逆序对个数，但是真正的个数我们其实并不太需要，只需要知道奇偶性就行了；我们知道一个长度为len长的序列，它的逆序对最多为 $len\cdot(len-1)/2$ (假如该序列为从大到小排序，即总逆序对个数为 ($1+2+3+\dots+(len-1)=len\cdot(len-1)/2$) 暂且称为满逆序对,那么现逆序对个数即与满逆序对个数有关，若满逆序对个数为偶数个，那么现逆序对奇偶性与原逆序对相同，即为加减偶数个数，可以用 $len\cdot(len-1)/2$ 代替，否则当满逆序对个数为奇数个时，那么现逆序对奇偶性与原逆序对相反，即为加减奇数个，也可用 $len\cdot(len-1)/2$ 代替，所以每次只需要将 $res+=len\cdot(len-1)/2$ 后就可以直接判断奇偶性，$O(1)$ 出答案。 AC代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1500;int n, m, cnt;int a[maxn + 5];int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) if(a[i] &gt; a[j])cnt++; &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); cnt += (r - l + 1) * (r - l) / 2; if(cnt &amp; 1)printf("odd\n"); else printf("even\n"); &#125; return 0;&#125; 题目链接：Go to!]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2FHELLO%20WORLD%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
