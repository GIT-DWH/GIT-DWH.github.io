<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[音乐测试]]></title>
    <url>%2F2018%2F03%2F19%2F%E9%9F%B3%E4%B9%90%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-C-Array Gcd]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-C-Array-Gcd%2F</url>
    <content type="text"><![CDATA[解题思路：​ 我们考虑到1操作也就是移除连续的一段区间的元素只能操作一次，而且长度是小于n的，那么最后得到的序列肯定是含有第一个元素或者是最后一个元素，那么根据这个性质我们就可以将 $a[1], a[1] +1, a[1] - 1, a[n], a[n] + 1, a[n] - 1$， 这6个数质数分解将质因子存在来，然后去枚举质因子， 对于每一个质因子序列里的每一个数成为这个质因子的代价是不同的，如果 $a[i]$ % $p$ = 0, $cost[i]$ = $0$、 ($a[i]$ +1) % $p$ = $0$ || ($a[i]$ - 1) % p = $0$, $cost[i]$ = $B$, 否则 $cost[i]$ = oo。那么这个时候我们就可以 $dp$ 了， $dp[i][0]$ 表示从一到 $i $ 这个位置还没有进行1操作的最小花费。$dp[i][1]$ 表示从一到 $i$ 这个位置正在进行1操作的最小花费。$dp[i][2]$ 表示从一到 $i$ 这个位置已经结束1操作了的最小花费。 AC代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;const int MaxN = 1e6;typedef long long LL;const LL Max = 1000000000000000000;using namespace std;LL n;LL a, b, c[MaxN + 5], dp[MaxN + 5][4];LL cost[MaxN + 5];vector &lt;LL&gt; G;void G_insert(LL x)&#123; for(LL i = 2;i * i &lt;= x;i++)&#123; if(x % i == 0)&#123; G.push_back(i); while(x % i == 0) x /= i; &#125; &#125; if(x != 1) G.push_back(x);&#125;void Init()&#123; G.clear(); for(int i = 1;i &lt;= n;i++) scanf("%I64d" , &amp;c[i]); for(LL i = -1;i &lt;= 1;i++) G_insert(c[1] + i); for(LL i = -1;i &lt;= 1;i++) G_insert(c[n] + i);&#125;LL Work(LL x)&#123; for(int i = 1;i &lt;= n;i++)&#123; cost[i] = dp[i][0] = dp[i][1] = dp[i][2] = 1LL &lt;&lt; 40; if(c[i] % x == 0) cost[i] = 0; else if((c[i] - 1) % x == 0 || (c[i] + 1) % x == 0) cost[i] = b; &#125; dp[0][0] = dp[0][1] = dp[0][2] = 0; for(int i = 1;i &lt;= n;i++)&#123; dp[i][0] = dp[i - 1][0] + cost[i]; dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a; dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + cost[i]; &#125; return min(dp[n][0] , min(dp[n][1], dp[n][2]));&#125;void Solve()&#123; LL ans = 1LL &lt;&lt; 60; for(int i = 0;i &lt; G.size();i++)&#123; ans = min(ans , Work(G[i])); &#125; printf("%I64d\n" , ans);&#125;int main()&#123; while(~scanf("%I64d%I64d%I64d" , &amp;n , &amp;a , &amp;b))&#123; Init(); Solve(); &#125;&#125;]]></content>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四校联赛2-D-D商店]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B2-D-D%E5%95%86%E5%BA%97%2F</url>
    <content type="text"><![CDATA[题目大意：​ 先输入 $n，k$ 分别代表有 $n$ 天，可以让任意 $k$ 天的的物品数量翻倍(每天最多只能翻一次）。接下来有 $n$ 行，第 $i$ 行有两个数 $ai，bi$ 分别代表在第 $i$ 天有 $ai$ 件物品，有 $bi$ 个顾客。每个顾客都会买一件物品。问 n 天后最多卖出多少件物品? 数据范围：$1 \leq n \leq 10^5$ $0 \leq k \leq n$ $1 \leq a_i ,bi\leq 10^9$ 解题思路： 当天的存货量大于等于需求量的时候，这一天的存货量是不需要翻倍的。 当天存货量小于需求量的时候，先让这一天的存货量翻倍，求出当天 ”可增加“ 的销售量，然后根据可增加的销售量从大到小排序，选出前 $k$ 天。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxn = 1e5 + 5;LL a[maxn],b[maxn],s[maxn];LL cmp(LL x,LL y)&#123; return x &gt; y;&#125;int main()&#123; int n,k; LL ans = 0,sum; scanf("%d %d",&amp;n,&amp;k); for(int i = 1;i &lt;= n;i++)&#123; scanf("%I64d %I64d",&amp;a[i],&amp;b[i]); if(b[i] &gt; a[i])&#123; if(2 * a[i] &lt;= b[i]) s[i] = a[i]; else s[i] = b[i] - a[i]; &#125; else&#123; s[i] = 0; a[i] = b[i]; &#125; &#125; sort(s + 1,s + n + 1,cmp); for(int i = 1;i &lt;= k;i++) ans += s[i]; for(int i = 1;i &lt;= n;i++) ans += a[i]; printf("%I64d",ans);&#125;]]></content>
      <tags>
        <tag>四校联赛2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces911D---Inversion Counting]]></title>
    <url>%2F2018%2F03%2F16%2FCodeforces911D---Inversion%20Counting%2F</url>
    <content type="text"><![CDATA[题目大意：给你 $n$ 个数，和 $m$ 个操作询问，每个询问给你 $l,r$ 两个数，问你反转 $l,r$ 区间的元素后，整个序列的逆序对的个数是奇数个还是偶数个，奇数个输出 $odd$ ,偶数个则输出 $even$ ,该逆序对以从小到大为标准次序，反转后不会恢复为原序列，且保证 $n$ 个数中每个数都不相同。 数据范围$1 \leq n \leq 1500,1 \leq m \leq 2 \cdot 10^5,1 \leq l_i \leq r_i \leq n,1 \leq a_i \leq n;​$ 解题思路：因为要求每次操作后逆序对的对数的奇偶性，如果想暴力做的话，每次对序列进行反转就是 $O(n)$ 的复杂度，还得重新求总逆序对个数，总复杂度就变为了 $O(n^{2}\cdot{m})$ ，这显然会 $TLE$ 的，所以得换个想法，我们先求出初始序列的总逆序对个数 $res$ ，根据 $[l,r]$ 区间逆序对的变化转换为总逆序对个数，但是真正的个数我们其实并不太需要，只需要知道奇偶性就行了；我们知道一个长度为len长的序列，它的逆序对最多为 $len\cdot(len-1)/2$ (假如该序列为从大到小排序，即总逆序对个数为 ($1+2+3+\dots+(len-1)=len\cdot(len-1)/2$) 暂且称为满逆序对,那么现逆序对个数即与满逆序对个数有关，若满逆序对个数为偶数个，那么现逆序对奇偶性与原逆序对相同，即为加减偶数个数，可以用 $len\cdot(len-1)/2$ 代替，否则当满逆序对个数为奇数个时，那么现逆序对奇偶性与原逆序对相反，即为加减奇数个，也可用 $len\cdot(len-1)/2$ 代替，所以每次只需要将 $res+=len\cdot(len-1)/2$ 后就可以直接判断奇偶性，$O(1)$ 出答案。 AC代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 1500;int n, m, cnt;int a[maxn + 5];int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++)scanf("%d", &amp;a[i]); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) if(a[i] &gt; a[j])cnt++; &#125; scanf("%d", &amp;m); for(int i = 1; i &lt;= m; i++) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); cnt += (r - l + 1) * (r - l) / 2; if(cnt &amp; 1)printf("odd\n"); else printf("even\n"); &#125; return 0;&#125; 题目链接：Go to!]]></content>
      <tags>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2FHELLO%20WORLD%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
