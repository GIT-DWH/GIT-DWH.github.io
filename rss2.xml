<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>天之界</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>踏一步便是虚无</description>
    <pubDate>Thu, 15 Nov 2018 04:56:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>树链剖分模板</title>
      <link>http://yoursite.com/2018/11/15/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E6%A8%A1%E6%9D%BF/</link>
      <guid>http://yoursite.com/2018/11/15/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E6%A8%A1%E6%9D%BF/</guid>
      <pubDate>Thu, 15 Nov 2018 04:45:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/278098/1541476016168/thumb_Tue_Nov_06_2018.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/278098/1541476016168/thumb_Tue_Nov_06_2018.jpg" alt="img"></p><a id="more"></a><h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h2><p><a href="https://www.cnblogs.com/ivanovcraft/p/9019090.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivanovcraft/p/9019090.html</a></p><h2 id="详情："><a href="#详情：" class="headerlink" title="详情："></a>详情：</h2><p>树剖是通过轻重边剖分将树分割成多条链，然后利用数据结构来维护这些链（本质上是一种优化暴力）</p><p>首先明确概念：</p><p>重儿子：父亲节点的所有儿子中子树结点数目最多（size最大）的结点；</p><p>轻儿子：父亲节点中除了重儿子以外的儿子；</p><p>重边：父亲结点和重儿子连成的边；</p><p>轻边：父亲节点和轻儿子连成的边；</p><p>重链：由多条重边连接而成的路径；</p><p>轻链：由多条轻边连接而成的路径；</p><p><img src="https://images2018.cnblogs.com/blog/1397737/201805/1397737-20180510123640544-303874904.png" alt="img"></p><p>比如上面这幅图中，用黑线连接的结点都是重结点，其余均是轻结点，</p><p>2-11就是重链，2-5就是轻链，用红点标记的就是该结点所在重链的起点，也就是下文提到的top结点，</p><p>还有每条边的值其实是进行dfs时的执行序号。</p><p><img src="https://images2018.cnblogs.com/blog/1397737/201805/1397737-20180510124617970-666005311.png" alt="img"></p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>f[u]</td><td>保存结点u的父亲节点</td></tr><tr><td>d[u]</td><td>保存结点u的深度值</td></tr><tr><td>size[u]</td><td>保存以u为根的子树节点个数</td></tr><tr><td>son[u]</td><td>保存重儿子</td></tr><tr><td>rk[u]</td><td>保存当前dfs标号在树中所对应的节点</td></tr><tr><td>top[u]</td><td>保存当前节点所在链的顶端节点</td></tr><tr><td>id[u]</td><td>保存树中每个节点剖分以后的新编号（DFS的执行顺序）</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>变量声明：</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;e[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum,lazy,l,r,ls,rs;</span><br><span class="line">&#125;node[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="keyword">int</span> rt,n,m,r,a[maxn],cnt,head[maxn],f[maxn],d[maxn],size[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>在dfs过程中顺便记录其父亲以及深度（即处理出f,d数组），操作<span class="number">1</span>,<span class="number">2</span>可以通过一遍dfs完成</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> depth)</span>    <span class="comment">//当前节点、父节点、层次深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u]=fa;</span><br><span class="line">    d[u]=depth;</span><br><span class="line">    size[u]=<span class="number">1</span>;    <span class="comment">//这个点本身size=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v,u,depth+<span class="number">1</span>);    <span class="comment">//层次深度+1</span></span><br><span class="line">        size[u]+=size[v];    <span class="comment">//子节点的size已被处理，用它来更新父节点的size</span></span><br><span class="line">        <span class="keyword">if</span>(size[v]&gt;size[son[u]])</span><br><span class="line">            son[u]=v;    <span class="comment">//选取size最大的作为重儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进入</span></span><br><span class="line">dfs1(root,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>第二遍dfs，然后连接重链，同时标记每一个节点的dfs序，并且为了用数据结构来维护重链，我们在dfs时保证一条重链上各个节点dfs序连续（即处理出数组top,id,rk）</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t)</span>    <span class="comment">//当前节点、重链顶端</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u]=t;</span><br><span class="line">    id[u]=++cnt;    <span class="comment">//标记dfs序</span></span><br><span class="line">    rk[cnt]=u;    <span class="comment">//序号cnt对应节点u</span></span><br><span class="line">    <span class="keyword">if</span>(!son[u])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[u],t);</span><br><span class="line"><span class="comment">/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续，</span></span><br><span class="line"><span class="comment">一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v!=son[u]&amp;&amp;v!=f[u])</span><br><span class="line">            dfs2(v,v);    <span class="comment">//一个点位于轻链底端，那么它的top必然是它本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>两遍dfs就是树链剖分的主要处理，通过dfs我们已经保证一条重链上各个节点dfs序连续，那么可以想到，我们可以通过数据结构（以线段树为例）来维护一条重链的信息</span><br><span class="line">回顾上文的那个题目，修改和查询操作原理是类似的，以查询操作为例，其实就是个LCA，不过这里使用了top来进行加速，因为top可以直接跳转到该重链的起始结点，轻链没有起始结点之说，他们的top就是自己。需要注意的是，每次循环只能跳一次，并且让结点深的那个来跳到top的位置，避免两个一起跳从而插肩而过。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,fx=top[x],fy=top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx!=fy)    <span class="comment">//两点不在同一条重链</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[fx]&gt;=d[fy])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=query(id[fx],id[x],rt);    <span class="comment">//线段树区间求和，处理这条重链的贡献</span></span><br><span class="line">            x=f[fx],fx=top[x];    <span class="comment">//将x设置成原链头的父亲结点，走轻边，继续循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+=query(id[fy],id[y],rt);</span><br><span class="line">            y=f[fy],fy=top[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束，两点位于同一重链上，但两点不一定为同一点，所以我们还要统计这两点之间的贡献</span></span><br><span class="line">    <span class="keyword">if</span>(id[x]&lt;=id[y])</span><br><span class="line">        ans+=query(id[x],id[y],rt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans+=query(id[y],id[x],rt);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>，树链剖分的时间复杂度</span><br><span class="line">树链剖分的两个性质：</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)如果(u, v)是一条轻边，那么size(v) &lt; size(u)/<span class="number">2</span>；</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)从根结点到任意结点的路所经过的轻重链的个数必定都小于logn；</span><br><span class="line"></span><br><span class="line">可以证明，树链剖分的时间复杂度为O(nlog^<span class="number">2</span>n)</span><br><span class="line"></span><br><span class="line">性质 <span class="number">1</span>:轻边(U,V)，size(V)&lt;=size(U)/<span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">性质 <span class="number">2</span>:从根到某一点的路径上，不超过O(logN)条轻边，不超过O(logN)条重路径。</span><br><span class="line"></span><br><span class="line">对于性质<span class="number">1</span>，我们肉眼观察法和反证法都能解决。</span><br><span class="line"></span><br><span class="line">对于性质<span class="number">2</span>就不是那么明显了，我们来证明一下：</span><br><span class="line"></span><br><span class="line">由性质<span class="number">1</span>可知，每经过一条轻边，子树的节点个数至少减少一半，所以至多经过 O (<span class="built_in">log</span> n ) 条轻边。</span><br><span class="line"></span><br><span class="line">而进入（或从……出去）一条重路径，一定需要经过一条轻边，所以至多经过 O (<span class="built_in">log</span> n ) 条重路径。</span><br><span class="line"></span><br><span class="line">有了以上两个性质之后，我们就可以发现这种分法的优越性了，我们仅仅只需要搜大概logn级别即可。</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/15/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E6%A8%A1%E6%9D%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces - gym - 101611 - C.Carpet(树链剖分)</title>
      <link>http://yoursite.com/2018/11/15/Codeforces%20-%20gym%20-%20101611%20-%20C.Carpet(%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86)/</link>
      <guid>http://yoursite.com/2018/11/15/Codeforces%20-%20gym%20-%20101611%20-%20C.Carpet(%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86)/</guid>
      <pubDate>Thu, 15 Nov 2018 04:32:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/278723/1541564729801/thumb_Wed_Nov_07_2018.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/278723/1541564729801/thumb_Wed_Nov_07_2018.jpg" alt="img"></p><a id="more"></a><p>##题目链接： </p><p><a href="http://codeforces.com/gym/101611/problem/C" target="_blank" rel="noopener">http://codeforces.com/gym/101611/problem/C</a></p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你一个 $n$ 个点的数，叫你放在一个 $1000000 * 20$ 的矩阵里，每个格子放一个点，还要保证边不能相交，输出每个点放的位置。</p><h2 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h2><ul><li>$1 &lt;= n &lt;= 100000$</li></ul><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>$input$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 2</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">4 2</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><p>$output$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>看到树，和  $20$ ，第一反应就应该想到树链剖分，因为树链剖分有一个性质：一个点到另一个点的过程中，经过的轻边不超过 $lg(n)$ ，经过的重链不超过 $lg(n)$。</p><p>剖分完后，就应该要考虑怎么放使得边不相交了。因为轻边的要放在下一层的，所以在 $dfs$ 时，先遍历轻边，把对应的点先放到下一层，然后在遍历重链。如果先放重链的话，就边会有交叉，因为 $dfs$ 时，重链上的轻边会放在，之前轻边的前面，导致边交叉。</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">2</span> * maxn],other[<span class="number">2</span> * maxn],last[maxn];</span><br><span class="line"><span class="keyword">int</span> all = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> siz[maxn],pos[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> son[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">pre[++all] = last[x];</span><br><span class="line">last[x] = all;</span><br><span class="line">other[all] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(last,<span class="number">-1</span>,<span class="keyword">sizeof</span>(last)); all = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(node,<span class="number">0</span>,<span class="keyword">sizeof</span>(node));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) siz[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) son[i] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(pos,<span class="number">0</span>,<span class="keyword">sizeof</span>(pos));</span><br><span class="line">pos[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ma = <span class="number">0</span>,tmp = x;</span><br><span class="line"><span class="keyword">int</span> dt = last[x];</span><br><span class="line"><span class="keyword">while</span>(dt != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> dr = other[dt];</span><br><span class="line"><span class="keyword">if</span>(dr != fa)&#123;</span><br><span class="line">dfs1(dr,x);</span><br><span class="line">siz[x] += siz[dr];</span><br><span class="line"><span class="keyword">if</span>(siz[dr] &gt; ma)&#123;</span><br><span class="line">ma = siz[dr];</span><br><span class="line">son[x] = dr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dt = pre[dt];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dt = last[x];</span><br><span class="line"><span class="keyword">while</span>(dt !=- <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> dr = other[dt];</span><br><span class="line"><span class="keyword">if</span>(dr != fa)&#123;</span><br><span class="line"><span class="keyword">if</span>(dr != son[x])&#123;</span><br><span class="line"><span class="keyword">int</span> deep = node[x].y;</span><br><span class="line">node[dr].y = deep + <span class="number">1</span>;</span><br><span class="line">node[dr].x = pos[deep + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">pos[deep + <span class="number">1</span>]++;</span><br><span class="line">dfs2(dr,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dt = pre[dt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> dr = son[x];</span><br><span class="line"><span class="keyword">int</span> deep = node[x].y;</span><br><span class="line">node[dr].y = deep;</span><br><span class="line">node[dr].x = pos[deep] + <span class="number">1</span>;</span><br><span class="line">pos[deep]++;</span><br><span class="line">dfs2(dr,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">Init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x,&amp;y);</span><br><span class="line">Build(x,y);</span><br><span class="line">Build(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">node[<span class="number">1</span>].x = <span class="number">1</span>,node[<span class="number">1</span>].y = <span class="number">1</span>;</span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,node[i].x,node[i].y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/15/Codeforces%20-%20gym%20-%20101611%20-%20C.Carpet(%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RMQ模板</title>
      <link>http://yoursite.com/2018/11/14/RMQ%E6%A8%A1%E6%9D%BF/</link>
      <guid>http://yoursite.com/2018/11/14/RMQ%E6%A8%A1%E6%9D%BF/</guid>
      <pubDate>Wed, 14 Nov 2018 13:45:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/9272/1541463438334/thumb_Mon_Nov_05_2018.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/9272/1541463438334/thumb_Mon_Nov_05_2018.jpg" alt="img"></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">19</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">MAX[i][j] = max(MAX[i][j - <span class="number">1</span>], MAX[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">MIN[i][j] = min(MIN[i][j - <span class="number">1</span>], MIN[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MaxN + <span class="number">2</span>; i++) LOG[i] = <span class="built_in">log</span>(<span class="number">1.0</span> * i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxnum = max(MAX[l][k], MAX[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line"><span class="keyword">int</span> minnum = min(MIN[l][k], MIN[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/14/RMQ%E6%A8%A1%E6%9D%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces - gym - 101505 - F.Tree Stands(树形DP计数)</title>
      <link>http://yoursite.com/2018/11/14/Codeforces%20-%20gym%20-%20101505%20-%20F.Tree%20Stands(%E6%A0%91%E5%BD%A2DP%E8%AE%A1%E6%95%B0)/</link>
      <guid>http://yoursite.com/2018/11/14/Codeforces%20-%20gym%20-%20101505%20-%20F.Tree%20Stands(%E6%A0%91%E5%BD%A2DP%E8%AE%A1%E6%95%B0)/</guid>
      <pubDate>Wed, 14 Nov 2018 13:45:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/9272/1541463710548/thumb_Mon_Nov_05_2018.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/9272/1541463710548/thumb_Mon_Nov_05_2018.jpg" alt="img"></p><a id="more"></a><h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="http://codeforces.com/gym/101505/attachments" target="_blank" rel="noopener">http://codeforces.com/gym/101505/attachments</a></p><h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h2><p><a href="https://blog.csdn.net/qq_36398723/article/details/77200526" target="_blank" rel="noopener">https://blog.csdn.net/qq_36398723/article/details/77200526</a></p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><ul><li>给定一棵树，求问猎人在树上站法的合法方案，树有 $n$ 个结点，$m$ 个猎人</li><li>每一个合法的站点至少有一个与其连通的节点上有人站 </li><li>一棵树最多站一个人</li><li>人之间不做区分</li></ul><h2 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h2><ul><li>$2&lt;=m &lt;= n &lt;= 200$</li></ul><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>$input$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">1 3</span><br><span class="line"></span><br><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><p>$output$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line"></span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>见代码</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line">LL dp[maxn][maxn][<span class="number">3</span>];</span><br><span class="line">LL tmp[maxn][maxn][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//dp[i][j][k]数组代表以i为根的树上站了j个人且树根i的状态为k的方案数</span></span><br><span class="line"><span class="comment">//tmp[i][j][k]用于计算dp数组的辅助数组，对每一个根节点，代表前i个子树分配了j个人，且状态和为k的方案</span></span><br><span class="line"><span class="comment">//这里指的状态和是指全部子树合在一起的状态，而且在搜索中"此时"根节点u不站人</span></span><br><span class="line"><span class="comment">//状态和解释：no_stand状态是指正在搜索的结点的前i个子树的根节点都不站人</span></span><br><span class="line"><span class="comment">//            safe状态是指正在搜索的结点的前i个子树没有不安全的结点，而且至少有一个处于safe状态的子节点</span></span><br><span class="line"><span class="comment">//            Notsafe状态是指......至少有一个处于Notsafe的结点</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//关于三种状态:</span></span><br><span class="line"><span class="comment">//0:代表树根上不站人的合法状态</span></span><br><span class="line"><span class="comment">//1:代表树根上站了的人的安全状态</span></span><br><span class="line"><span class="comment">//2:代表树根上站了人的不安全状态,但是它的所有子树都安全(这里指子树的根节点都处于no_stand状态),这个状态可以通过在该节点的父亲上放个人来变为合法状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[u].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span>(v != fa)&#123;</span><br><span class="line">dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">tmp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1L</span>L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pos = <span class="number">1</span>;pos &lt;= G[u].size();pos++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][pos - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">siz++;</span><br><span class="line"><span class="keyword">int</span> i = siz;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= k;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>;p &lt;= j;p++)&#123;</span><br><span class="line">tmp[i][j][<span class="number">0</span>] = (tmp[i][j][<span class="number">0</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">0</span>] * dp[v][j - p][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line"></span><br><span class="line">tmp[i][j][<span class="number">1</span>] = (tmp[i][j][<span class="number">1</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">1</span>] * dp[v][j - p][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">tmp[i][j][<span class="number">1</span>] = (tmp[i][j][<span class="number">1</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">1</span>] * dp[v][j - p][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">tmp[i][j][<span class="number">1</span>] = (tmp[i][j][<span class="number">1</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">0</span>] * dp[v][j - p][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line"></span><br><span class="line">tmp[i][j][<span class="number">2</span>] = (tmp[i][j][<span class="number">2</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">0</span>] * dp[v][j - p][<span class="number">2</span>]) % mod) % mod;</span><br><span class="line">tmp[i][j][<span class="number">2</span>] = (tmp[i][j][<span class="number">2</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">1</span>] * dp[v][j - p][<span class="number">2</span>]) % mod) % mod;</span><br><span class="line">tmp[i][j][<span class="number">2</span>] = (tmp[i][j][<span class="number">2</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">2</span>] * dp[v][j - p][<span class="number">2</span>]) % mod) % mod;</span><br><span class="line">tmp[i][j][<span class="number">2</span>] = (tmp[i][j][<span class="number">2</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">2</span>] * dp[v][j - p][<span class="number">1</span>]) % mod) % mod;</span><br><span class="line">tmp[i][j][<span class="number">2</span>] = (tmp[i][j][<span class="number">2</span>] + (tmp[i - <span class="number">1</span>][p][<span class="number">2</span>] * dp[v][j - p][<span class="number">0</span>]) % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[u][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1L</span>L;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++)&#123;</span><br><span class="line">dp[u][i][<span class="number">0</span>] = (tmp[siz][i][<span class="number">0</span>] + tmp[siz][i][<span class="number">1</span>]) % mod;</span><br><span class="line">dp[u][i][<span class="number">1</span>] = (tmp[siz][i - <span class="number">1</span>][<span class="number">1</span>] + tmp[siz][i - <span class="number">1</span>][<span class="number">2</span>]) % mod;</span><br><span class="line">dp[u][i][<span class="number">2</span>] = tmp[siz][i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k))&#123;</span><br><span class="line">Init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(dp[<span class="number">1</span>][k][<span class="number">0</span>] + dp[<span class="number">1</span>][k][<span class="number">1</span>]) % mod);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) G[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考博客代码：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> no_stand 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> safe 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> notSafe 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> llt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">201</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> tree[N][N],treeCnt[N];</span><br><span class="line"><span class="comment">//treeCnt[N]记录子树的个数</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N][<span class="number">3</span>],tmp[N][N][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//dp[i][j][k]数组代表以i为根的树上站了j个人且树根i的状态为k的方案数</span></span><br><span class="line"><span class="comment">//tmp[i][j][k]用于计算dp数组的辅助数组，对每一个根节点，代表前i个子树分配了j个人，且状态和为k的方案</span></span><br><span class="line"><span class="comment">//这里指的状态和是指全部子树合在一起的状态，而且在搜索中"此时"根节点u不站人</span></span><br><span class="line"><span class="comment">//状态和解释：no_stand状态是指正在搜索的结点的前i个子树的根节点都不站人</span></span><br><span class="line"><span class="comment">//            safe状态是指正在搜索的结点的前i个子树没有不安全的结点，而且至少有一个处于safe状态的子节点</span></span><br><span class="line"><span class="comment">//            Notsafe状态是指......至少有一个处于Notsafe的结点</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//关于三种状态:</span></span><br><span class="line"><span class="comment">//0:代表树根上不站人的合法状态</span></span><br><span class="line"><span class="comment">//1:代表树根上站了的人的安全状态</span></span><br><span class="line"><span class="comment">//2:代表树根上站了人的不安全状态,但是它的所有子树都安全(这里指子树的根节点都处于no_stand状态),这个状态可以通过在该节点的父亲上放个人来变为合法状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sz = treeCnt[now];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sz;i++)&#123;</span><br><span class="line">    dfs(tree[now][i]);</span><br><span class="line">    <span class="comment">//printf("** %d %d\n",tree[now][i],now);</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="number">3</span> * N * N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//前0个子树站了一个0个节点而且全部没有站人(因为根本没有子树)</span></span><br><span class="line">    tmp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1L</span>L;</span><br><span class="line"><span class="comment">//对前i个子树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= sz;i++)&#123;</span><br><span class="line"><span class="comment">//第i个子树个根为v</span></span><br><span class="line">        <span class="keyword">int</span> v = tree[now][i - <span class="number">1</span>];</span><br><span class="line"><span class="comment">//给前i个子树分配j个人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= m;j++)&#123;</span><br><span class="line"><span class="comment">//给前i-1个子树分配k个人，那么第i个子树就分配j-k个人</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= j;k++)&#123;</span><br><span class="line"><span class="comment">//前i个子树树根不站人：前i-1个子树树根不站人，且第i个子树树根不站人</span></span><br><span class="line">                tmp[i][j][<span class="number">0</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">0</span>] * dp[v][j - k][<span class="number">0</span>]) % MOD; tmp[i][j][<span class="number">0</span>] %= MOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前i个子树有&gt;=1个子树站了人的合法状态：前i-1个子树树根不站人，第i个子树安全</span></span><br><span class="line">                tmp[i][j][<span class="number">1</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">0</span>] * dp[v][j - k][<span class="number">1</span>]) % MOD; tmp[i][j][<span class="number">1</span>] %= MOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前i个子树有&gt;=1个子树站了人的合法状态：前i-1个子树安全，第i个子树树根不站人</span></span><br><span class="line">                tmp[i][j][<span class="number">1</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">1</span>] * dp[v][j - k][<span class="number">0</span>]) % MOD; tmp[i][j][<span class="number">1</span>] %= MOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前i个子树有&gt;=1个子树站了人的合法状态：前i-1个子树安全，第i个子树树根站人且安全</span></span><br><span class="line">                tmp[i][j][<span class="number">1</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">1</span>] * dp[v][j - k][<span class="number">1</span>]) % MOD; tmp[i][j][<span class="number">1</span>] %= MOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前i个子树树根站人且树根上的人不安全：枚举一下，前i-1个子树或者第i个子树有一个不安全即为不安全状态，所以有5种</span></span><br><span class="line">                tmp[i][j][<span class="number">2</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">0</span>] * dp[v][j - k][<span class="number">2</span>]) % MOD; tmp[i][j][<span class="number">2</span>] %= MOD;</span><br><span class="line"></span><br><span class="line">                tmp[i][j][<span class="number">2</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">2</span>] * dp[v][j - k][<span class="number">0</span>]) % MOD; tmp[i][j][<span class="number">2</span>] %= MOD;</span><br><span class="line"></span><br><span class="line">                tmp[i][j][<span class="number">2</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">1</span>] * dp[v][j - k][<span class="number">2</span>]) % MOD; tmp[i][j][<span class="number">2</span>] %= MOD;</span><br><span class="line"></span><br><span class="line">                tmp[i][j][<span class="number">2</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">2</span>] * dp[v][j - k][<span class="number">1</span>]) % MOD; tmp[i][j][<span class="number">2</span>] %= MOD;</span><br><span class="line"></span><br><span class="line">                tmp[i][j][<span class="number">2</span>] += ((llt)tmp[i - <span class="number">1</span>][k][<span class="number">2</span>] * dp[v][j - k][<span class="number">2</span>]) % MOD; tmp[i][j][<span class="number">2</span>] %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于每一个结点为根的结点站了0个人的方法总数为1</span></span><br><span class="line">    dp[now][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//  printf("now = %d , sz = %d\n",now,sz);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="comment">//now节点不站人且安全：所有子树都不站人+所有子树都安全</span></span><br><span class="line">        dp[now][i][<span class="number">0</span>] = (tmp[sz][i][<span class="number">0</span>] + tmp[sz][i][<span class="number">1</span>]) % MOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//now结点站人且安全：所有子树都安全+（子树为不安全状态，但只有子树树根不安全，可以转化为安全状态）</span></span><br><span class="line">        dp[now][i][<span class="number">1</span>] = (tmp[sz][i - <span class="number">1</span>][<span class="number">1</span>] + tmp[sz][i - <span class="number">1</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line"></span><br><span class="line"><span class="comment">//now节点站人且不安全：所有子树都不站人</span></span><br><span class="line">        dp[now][i][<span class="number">2</span>] = tmp[sz][i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过搜索，删除所有指向父亲的边，这样每个节点边的数量就等于它子树的数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutEdge</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; treeCnt[now];)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = tree[now][i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) tree[now][i] = tree[now][--treeCnt[now]];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             cutEdge(v,now);</span><br><span class="line"> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">//先切除多余的边，形成一棵树</span></span><br><span class="line">    cutEdge(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//因为是从第一棵子树开始dfs的，所以答案是以第一棵树为根节点，有m个stands的合法状态之和</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(dp[<span class="number">1</span>][m][<span class="number">1</span>] + dp[<span class="number">1</span>][m][<span class="number">0</span>]) % MOD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m) != EOF )&#123;</span><br><span class="line">        <span class="built_in">memset</span>(treeCnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(treeCnt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u,v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="comment">//由于输入不是以父亲-儿子的顺序输入的，所以不知道树根，建立双向边，不然跑不通</span></span><br><span class="line"><span class="comment">//后面还需要删边,见cutEdge函数</span></span><br><span class="line">            tree[u][treeCnt[u]++] = v;</span><br><span class="line">            tree[v][treeCnt[v]++] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/14/Codeforces%20-%20gym%20-%20101505%20-%20F.Tree%20Stands(%E6%A0%91%E5%BD%A2DP%E8%AE%A1%E6%95%B0)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces - gym - 101630 - C.Connections(强连通+思维)</title>
      <link>http://yoursite.com/2018/11/11/Codeforces%20-%20gym%20-%20101630%20-%20C.Connections(%E5%BC%BA%E8%BF%9E%E9%80%9A+%E6%80%9D%E7%BB%B4)/</link>
      <guid>http://yoursite.com/2018/11/11/Codeforces%20-%20gym%20-%20101630%20-%20C.Connections(%E5%BC%BA%E8%BF%9E%E9%80%9A+%E6%80%9D%E7%BB%B4)/</guid>
      <pubDate>Sun, 11 Nov 2018 10:29:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/120/8/thumb.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/120/8/thumb.jpg" alt="img"></p><a id="more"></a><h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="http://codeforces.com/gym/101630/attachments" target="_blank" rel="noopener">http://codeforces.com/gym/101630/attachments</a></p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>$T$ 组数据，给你一幅有向图，有 $n$ 个点，$m$ 条边，问删除哪 $m - 2 * n$ 条边，可以使得剩下的图任意两点之间能互相到达。</p><h2 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h2><ul><li>$n &gt;= 4$</li><li>$m &gt; 2 * n$</li><li>$The$ $sum$ $of$ $m$ $over$ $all$ $test$ $cases$ $in$ $a$ $single$ $input$ $does$ $not$ $exceed$ $100 000$.</li></ul><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>$input$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">3 2</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">4 2</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><p>$output$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><ul><li><p>首先要注意 $n$ 的范围，因为 $m$ 最大为 $100000$，但 $n$ 不一定是小于 $1000$ 的，所以直接就开 $2e5$ , 这样能保证当点数为 $2e5$ 时，由 $100000$ 条边是一定形成不了强连通图的。</p></li><li><p>我们可以把 $1$ 点当做中转站，那么我们先从 $1$ 点跑到其他所有点，然后把经过的边给标记。接着我们把边反向建，形成一幅新的图，再从 $1$ 点跑到其他所有点（相当于所有点跑到 $1$ 点，若当前是 $u -&gt; v$ 那么把 $vis[v][u]$ 标记了。在一幅图中，若其他所有点能跑到 $1$ 点，那么反向建边后，从 $1$ 点一定能跑到其他所有点。</p></li><li><p>这样最多会标记 $2 * (n - 1)$ 条边，然后其他边可以随便选。因为这样保证一定能形成强连通图，也可以说强连通图有这个性质。</p></li></ul><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G1[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G2[maxn];</span><br><span class="line"><span class="keyword">bool</span> arrive[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;pii,<span class="keyword">bool</span>&gt; vis;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">arrive[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G1[u].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G1[u][i];</span><br><span class="line"><span class="keyword">if</span>(!arrive[v])&#123;</span><br><span class="line">vis[make_pair(u,v)] = <span class="number">1</span>;</span><br><span class="line">Dfs1(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">arrive[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G2[u].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> v = G2[u][i];</span><br><span class="line"><span class="keyword">if</span>(!arrive[v])&#123;</span><br><span class="line">vis[make_pair(u,v)] = <span class="number">1</span>;</span><br><span class="line">Dfs2(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">G1[i].clear();</span><br><span class="line">G2[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">vis.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">G1[x[i]].push_back(y[i]);</span><br><span class="line">G2[y[i]].push_back(x[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dfs1(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) arrive[i] = <span class="number">0</span>;</span><br><span class="line">Dfs2(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) arrive[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = m - <span class="number">2</span> * n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m &amp;&amp; cnt;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[make_pair(x[i],y[i])])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,x[i],y[i]);</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/11/Codeforces%20-%20gym%20-%20101630%20-%20C.Connections(%E5%BC%BA%E8%BF%9E%E9%80%9A+%E6%80%9D%E7%BB%B4)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces - gym - 101550 - C.Card Hand Sorting(最长公共子序列)</title>
      <link>http://yoursite.com/2018/11/05/Codeforces%20-%20gym%20-%20101550%20-%20C.Card%20Hand%20Sorting(%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97)/</link>
      <guid>http://yoursite.com/2018/11/05/Codeforces%20-%20gym%20-%20101550%20-%20C.Card%20Hand%20Sorting(%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97)/</guid>
      <pubDate>Mon, 05 Nov 2018 03:32:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/2/thumb.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/2/thumb.jpg" alt="img"></p><a id="more"></a><h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="http://codeforces.com/gym/101550/attachments" target="_blank" rel="noopener">http://codeforces.com/gym/101550/attachments</a></p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><ul><li><p>输入一个 $n$ 表示有 $n$ 张牌</p></li><li><p>牌一共有 $4$ 种颜色 ${s, h, d, c}$ </p></li><li><p>牌上的符号有(从小到大) ${2,3,4,5,6,7,8,9,T, J, Q, K,A}$  </p></li><li><p>每张牌给的格式为：符号+牌的颜色 如：$2h$ , $Jd$</p></li><li><p>问是否以一种排列满足</p><ul><li>相同颜色的牌放在一起</li><li>相同颜色的牌要 递增 或 递减 的排列</li><li>颜色的顺序可以随便</li></ul><p>使得这一种排列放回原来的排列步数最少的多少？</p></li></ul><h2 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h2><ul><li>$1 &lt;= n &lt;= 52$</li></ul><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>$input$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2h Th 8c Qh</span><br><span class="line"></span><br><span class="line">7</span><br><span class="line">9d As 2s Qd 2c Jd 8h</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">2h 3h 9c 8c</span><br></pre></td></tr></table></figure><p>$output$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>那么可以先暴力求出所有的排列情况，然后求出每种排列与原排列的最长公共子序列，那么答案为 $min(n - 最长公共子序列)$</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">55</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">55</span>],b[<span class="number">55</span>],p[<span class="number">6</span>],pos[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="string">'1'</span>;i &lt;= <span class="string">'9'</span>;i++) f[i] = i - <span class="string">'0'</span>;</span><br><span class="line">f[<span class="string">'T'</span>] = <span class="number">10</span>; f[<span class="string">'J'</span>] = <span class="number">11</span>;</span><br><span class="line">f[<span class="string">'Q'</span>] = <span class="number">12</span>; f[<span class="string">'K'</span>] = <span class="number">13</span>;</span><br><span class="line">f[<span class="string">'A'</span>] = <span class="number">14</span>;</span><br><span class="line">p[<span class="number">1</span>] = <span class="number">1</span>; p[<span class="number">2</span>] = <span class="number">2</span>; p[<span class="number">3</span>] = <span class="number">3</span>; p[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n + <span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= n + <span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) dp[i][j] = max(dp[i][j],dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = max(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n - dp[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">Init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">G[<span class="number">1</span>].clear(); G[<span class="number">2</span>].clear(); G[<span class="number">3</span>].clear(); G[<span class="number">4</span>].clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++) pos[p[i]] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][<span class="number">2</span>] == <span class="string">'s'</span>) a[i] = pos[<span class="number">1</span>] * <span class="number">100</span> + f[s[i][<span class="number">1</span>]], G[<span class="number">1</span>].push_back(a[i]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i][<span class="number">2</span>] == <span class="string">'h'</span>)&#123;</span><br><span class="line">                a[i] = pos[<span class="number">2</span>] * <span class="number">100</span> + f[s[i][<span class="number">1</span>]], G[<span class="number">2</span>].push_back(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i][<span class="number">2</span>] == <span class="string">'d'</span>)&#123;</span><br><span class="line">                a[i] = pos[<span class="number">3</span>] * <span class="number">100</span> + f[s[i][<span class="number">1</span>]], G[<span class="number">3</span>].push_back(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i][<span class="number">2</span>] == <span class="string">'c'</span>)&#123;</span><br><span class="line">                a[i] = pos[<span class="number">4</span>] * <span class="number">100</span> + f[s[i][<span class="number">1</span>]], G[<span class="number">4</span>].push_back(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">15</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((j &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>)&#123; <span class="comment">// small -&gt; big</span></span><br><span class="line">sort(G[p[i + <span class="number">1</span>]].begin(),G[p[i + <span class="number">1</span>]].end());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123; <span class="comment">// big -&gt; small</span></span><br><span class="line">sort(G[p[i + <span class="number">1</span>]].begin(),G[p[i + <span class="number">1</span>]].end(),cmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; G[p[i + <span class="number">1</span>]].size();k++)&#123;</span><br><span class="line">b[++tot] = G[p[i + <span class="number">1</span>]][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = min(ans,Solve());</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(next_permutation(p + <span class="number">1</span>,p + <span class="number">1</span> + <span class="number">4</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/05/Codeforces%20-%20gym%20-%20101550%20-%20C.Card%20Hand%20Sorting(%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>LCA模板</title>
      <link>http://yoursite.com/2018/11/04/LCA%E6%A8%A1%E6%9D%BF/</link>
      <guid>http://yoursite.com/2018/11/04/LCA%E6%A8%A1%E6%9D%BF/</guid>
      <pubDate>Sun, 04 Nov 2018 11:05:29 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/1/thumb.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/1/thumb.jpg" alt="img"></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAXN 500001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">25</span>], deep[MAXN];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; vec[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, v;</span><br><span class="line">    deep[u] = deep[f[u][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; f[u][i]; i++) f[u][i + <span class="number">1</span>] = f[f[u][i]][i];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; vec[u].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v = vec[u][i];</span><br><span class="line">        <span class="keyword">if</span>(!deep[v]) f[v][<span class="number">0</span>] = u, dfs(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(deep[f[x][i]] &gt;= deep[y])</span><br><span class="line">            x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(f[x][i] != f[y][i])</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;s)</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x = get_num();</span><br><span class="line">        y = get_num();</span><br><span class="line">        vec[x].push_back(y);</span><br><span class="line">        vec[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(s);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/04/LCA%E6%A8%A1%E6%9D%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces - gym - 101550 - A.Artwork(并查集)</title>
      <link>http://yoursite.com/2018/11/04/Codeforces%20-%20gym%20-%20101550%20-%20A.Artwork(%E5%B9%B6%E6%9F%A5%E9%9B%86)/</link>
      <guid>http://yoursite.com/2018/11/04/Codeforces%20-%20gym%20-%20101550%20-%20A.Artwork(%E5%B9%B6%E6%9F%A5%E9%9B%86)/</guid>
      <pubDate>Sun, 04 Nov 2018 06:22:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/11/thumb.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/11/thumb.jpg" alt="img"></p><a id="more"></a><h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="http://codeforces.com/gym/101550/attachments" target="_blank" rel="noopener">http://codeforces.com/gym/101550/attachments</a></p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>有一个 $n*m$ 的矩阵，初始格子都为白色，然后有 $q$ 个操作，每个操作给你一条线段的两个端点，$(x_1,y_1)$ $(x_2,y_2)$ , 然后把这条线段上的格子涂黑，问当前（每个操作不独立）有白色格子联通块？</p><h2 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h2><ul><li>$1 &lt;= n ,m&lt;= 1000$ </li><li>$1 &lt;= q &lt;= 1e4$</li><li>$1 &lt;= x_1 &lt;= x_2 &lt;= n$</li><li>$1 &lt;= y_1 &lt;= y_2 &lt;= m$</li><li>4s</li></ul><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>$input$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 6 5</span><br><span class="line">2 2 2 6</span><br><span class="line">1 3 4 3</span><br><span class="line">2 5 3 5</span><br><span class="line">4 6 4 6</span><br><span class="line">1 6 4 6</span><br></pre></td></tr></table></figure><p>$output$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>利用并查集，倒着推，在删除黑格时，判断四个方向会不会多产生白色联通块或减少联通块。</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn],ans[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,q,num,flag;</span><br><span class="line"><span class="keyword">int</span> nx,ny,id,nid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[MaxN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x_1,y_1;</span><br><span class="line"><span class="keyword">int</span> x_2,y_2;</span><br><span class="line">&#125;node[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetID</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m * (x - <span class="number">1</span>) + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> father[x] = Find(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> F)</span></span>&#123;</span><br><span class="line">vis[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> now = GetID(x,y);</span><br><span class="line"><span class="keyword">if</span>(Find(now) != F) father[Find(now)] = father[Find(F)];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-1</span>;i &lt;= <span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">-1</span>;j &lt;= <span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> nx = x + i;</span><br><span class="line"><span class="keyword">int</span> ny = y + j;</span><br><span class="line"><span class="keyword">if</span>(i * j == <span class="number">0</span> &amp;&amp; Check(nx,ny) &amp;&amp; !vis[nx][ny] &amp;&amp; a[nx][ny] == <span class="number">0</span>)&#123;</span><br><span class="line">Dfs(nx,ny,Find(now));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Check(nx,ny) &amp;&amp; a[nx][ny] == <span class="number">0</span>)&#123;</span><br><span class="line">nid = GetID(nx,ny);</span><br><span class="line"><span class="keyword">if</span>(Find(nid) != Find(id))&#123;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>) num--;</span><br><span class="line">father[Find(nid)] = father[Find(id)];</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">id = GetID(x,y);</span><br><span class="line">nx = x + <span class="number">1</span>; <span class="comment">// up</span></span><br><span class="line">ny = y;</span><br><span class="line">Get();</span><br><span class="line">nx = x - <span class="number">1</span>; <span class="comment">// down</span></span><br><span class="line">ny = y;</span><br><span class="line">Get();</span><br><span class="line">nx = x;     <span class="comment">// left</span></span><br><span class="line">ny = y - <span class="number">1</span>; </span><br><span class="line">Get();</span><br><span class="line">nx = x;    <span class="comment">// right</span></span><br><span class="line">ny = y + <span class="number">1</span>;</span><br><span class="line">Get();</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>) num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;node[i].x_1,&amp;node[i].y_1,&amp;node[i].x_2,&amp;node[i].y_2);</span><br><span class="line"><span class="keyword">if</span>(node[i].x_1 == node[i].x_2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = node[i].y_1;j &lt;= node[i].y_2;j++) a[node[i].x_1][j]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = node[i].x_1;j &lt;= node[i].x_2;j++) a[j][node[i].y_1]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n * m;i++) father[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">0</span> &amp;&amp; !vis[i][j])&#123;</span><br><span class="line">num++;</span><br><span class="line">Dfs(i,j,Find(GetID(i,j)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[q] = num;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = q;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].x_1 == node[i].x_2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = node[i].y_1;j &lt;= node[i].y_2;j++)&#123;</span><br><span class="line">a[node[i].x_1][j]--;</span><br><span class="line"><span class="keyword">int</span> nowx = node[i].x_1;</span><br><span class="line"><span class="keyword">int</span> nowy = j;</span><br><span class="line"><span class="keyword">if</span>(a[nowx][nowy] == <span class="number">0</span>)&#123;</span><br><span class="line">Solve(nowx,nowy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = node[i].x_1;j &lt;= node[i].x_2;j++)&#123;</span><br><span class="line">a[j][node[i].y_1]--;</span><br><span class="line"><span class="keyword">int</span> nowx = j;</span><br><span class="line"><span class="keyword">int</span> nowy = node[i].y_1;</span><br><span class="line"><span class="keyword">if</span>(a[nowx][nowy] == <span class="number">0</span>)&#123;</span><br><span class="line">Solve(nowx,nowy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[i - <span class="number">1</span>] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/04/Codeforces%20-%20gym%20-%20101550%20-%20A.Artwork(%E5%B9%B6%E6%9F%A5%E9%9B%86)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>读题单词</title>
      <link>http://yoursite.com/2018/11/04/%E8%AF%BB%E9%A2%98%E5%8D%95%E8%AF%8D/</link>
      <guid>http://yoursite.com/2018/11/04/%E8%AF%BB%E9%A2%98%E5%8D%95%E8%AF%8D/</guid>
      <pubDate>Sun, 04 Nov 2018 06:22:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/6/thumb.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/119/6/thumb.jpg" alt="img"></p><a id="more"></a><p>$excluding$ : 不包括</p><p>$ cheat$ : 作弊</p><p>$against​$ ：反对</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/11/04/%E8%AF%BB%E9%A2%98%E5%8D%95%E8%AF%8D/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Codeforces - gym - 101873 - C.Joyride!(Dijkstra+状态转移)</title>
      <link>http://yoursite.com/2018/10/29/Codeforces%20-%20gym%20-%20101873%20-%20C.Joyride!(Dijkstra+%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB)/</link>
      <guid>http://yoursite.com/2018/10/29/Codeforces%20-%20gym%20-%20101873%20-%20C.Joyride!(Dijkstra+%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB)/</guid>
      <pubDate>Mon, 29 Oct 2018 13:45:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/34579/1535724568669/thumb_Fri_Aug_31_2018.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/palette/34579/1535724568669/thumb_Fri_Aug_31_2018.jpg" alt="img"></p><a id="more"></a><h2 id="题目链接："><a href="#题目链接：" class="headerlink" title="题目链接："></a>题目链接：</h2><p><a href="https://codeforces.com/gym/101873/problem/C" target="_blank" rel="noopener">https://codeforces.com/gym/101873/problem/C</a></p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><ul><li>给你一副无向图，有 $n$ 个点，第 $i$ 个点花费时间为 $t_i$ 和 花费价钱为 $p_i$ </li><li>$m$ 条边，经过每条边的花费时间都为 $t$</li></ul><p>问：从 $1$ 点出发，最后回到 $1$ 点时花费时间恰好为 $x$ ，最少花费价钱为多少？（可以在同一个点不动，但还是要花费时间和价钱，只要经过就花），如果不能恰好到达 $1$ 点，就输出 $It$ $is$ $a$ $trap.$</p><h2 id="数据范围："><a href="#数据范围：" class="headerlink" title="数据范围："></a>数据范围：</h2><ul><li>$1 &lt;= x &lt;= 1000$</li><li>$1 &lt;= n,m &lt;= 1000$</li><li>$1 &lt;= t &lt;= 1000 $</li></ul><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><p>$input$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 4 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">5 4</span><br><span class="line">3 3</span><br><span class="line"></span><br><span class="line">6</span><br><span class="line">4 4 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">5 4</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><p>$output$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line"></span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>因为题目要求最小花费价钱，所以第一反应就要想到跑个最短路。那么现在的问题就是这么解决每个点的状态？</p><p>因为 $x$ 不超过 $1000$ ，我们可以把每个点的状态设为：$dp[i][j]$ 当在第 $i$ 点，花费时间为 $j$ 时的最少花费价钱。</p><p>然后我们就可以按照 $Dijkstra$ 转移了。(但这个复杂度我不太清楚这么算……)</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id,x,cost;</span><br><span class="line">Node () &#123;&#125;</span><br><span class="line">Node (<span class="keyword">int</span> _id,<span class="keyword">int</span> _x,<span class="keyword">int</span> _cost)&#123;</span><br><span class="line">id = _id;</span><br><span class="line">x = _x;</span><br><span class="line">cost = _cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span> &lt; (Node a,Node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span> * maxn + <span class="number">5</span>][maxn + <span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">2</span> * maxn + <span class="number">5</span>],p[<span class="number">2</span> * maxn + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> T,n,m,X;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= X;j++)&#123;</span><br><span class="line">dp[i][j] = inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[s][t[s]] = p[s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">Init(s);</span><br><span class="line">priority_queue&lt;Node&gt; pq;</span><br><span class="line">pq.push(Node(s,t[s],p[s]));</span><br><span class="line"><span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">Node now = pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[now.id].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">int</span> v = G[now.id][i];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(v - now.id) == n) tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> tmp = T;</span><br><span class="line">tmp = now.x + tmp + t[v];</span><br><span class="line"><span class="comment">//printf("tmp = %d ,v = %d\n",tmp,v);</span></span><br><span class="line"><span class="comment">//printf("** %d\n",dp[v][tmp]);</span></span><br><span class="line"><span class="comment">//printf("%d %d %d %d\n",now.id,now.x,p[v],dp[now.id][now.x] + p[v]);</span></span><br><span class="line"><span class="keyword">if</span>(tmp &lt;= X &amp;&amp; dp[v][tmp] &gt; dp[now.id][now.x] + p[v])&#123;</span><br><span class="line">dp[v][tmp] = dp[now.id][now.x] + p[v];</span><br><span class="line">pq.push(Node(v,tmp,dp[v][tmp]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span> * maxn + <span class="number">5</span>][<span class="number">2</span> * maxn + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;X);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;T);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;t[i],&amp;p[i]);</span><br><span class="line">t[i + n] = t[i];</span><br><span class="line">p[i + n] = p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G[i].size();j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = G[i][j];</span><br><span class="line"><span class="keyword">if</span>(vis[i + n][tmp] == <span class="number">0</span>)&#123;</span><br><span class="line">G[i + n].push_back(tmp);</span><br><span class="line">G[tmp].push_back(i + n);</span><br><span class="line">vis[i + n][tmp] = <span class="number">1</span>;</span><br><span class="line">vis[tmp][i + n] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[i + n][tmp + n] == <span class="number">0</span>)&#123;</span><br><span class="line">G[i + n].push_back(tmp + n);</span><br><span class="line">G[tmp + n].push_back(i + n);</span><br><span class="line">vis[i + n][tmp + n] = <span class="number">1</span>;</span><br><span class="line">vis[tmp + n][i + n] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">G[i].push_back(i + n);</span><br><span class="line">G[i + n].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">Dijstra(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> mi = inf;</span><br><span class="line">mi = min(mi,dp[<span class="number">1</span>][X]);</span><br><span class="line">mi = min(mi,dp[<span class="number">1</span> + n][X]);</span><br><span class="line"><span class="keyword">if</span>(mi == inf) <span class="built_in">printf</span>(<span class="string">"It is a trap.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/10/29/Codeforces%20-%20gym%20-%20101873%20-%20C.Joyride!(Dijkstra+%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB)/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
